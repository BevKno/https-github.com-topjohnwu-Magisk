// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `update_metadata.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.Extent)
pub struct Extent {
    // message fields
    // @@protoc_insertion_point(field:chromeos_update_engine.Extent.start_block)
    pub start_block: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:chromeos_update_engine.Extent.num_blocks)
    pub num_blocks: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.Extent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Extent {
    fn default() -> &'a Extent {
        <Extent as ::protobuf::Message>::default_instance()
    }
}

impl Extent {
    pub fn new() -> Extent {
        ::std::default::Default::default()
    }

    // optional uint64 start_block = 1;

    pub fn start_block(&self) -> u64 {
        self.start_block.unwrap_or(0)
    }

    pub fn clear_start_block(&mut self) {
        self.start_block = ::std::option::Option::None;
    }

    pub fn has_start_block(&self) -> bool {
        self.start_block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_block(&mut self, v: u64) {
        self.start_block = ::std::option::Option::Some(v);
    }

    // optional uint64 num_blocks = 2;

    pub fn num_blocks(&self) -> u64 {
        self.num_blocks.unwrap_or(0)
    }

    pub fn clear_num_blocks(&mut self) {
        self.num_blocks = ::std::option::Option::None;
    }

    pub fn has_num_blocks(&self) -> bool {
        self.num_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_blocks(&mut self, v: u64) {
        self.num_blocks = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_block",
            |m: &Extent| { &m.start_block },
            |m: &mut Extent| { &mut m.start_block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_blocks",
            |m: &Extent| { &m.num_blocks },
            |m: &mut Extent| { &mut m.num_blocks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Extent>(
            "Extent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Extent {
    const NAME: &'static str = "Extent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_block = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.num_blocks = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_block {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.num_blocks {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_block {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.num_blocks {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Extent {
        Extent::new()
    }

    fn clear(&mut self) {
        self.start_block = ::std::option::Option::None;
        self.num_blocks = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Extent {
        static instance: Extent = Extent {
            start_block: ::std::option::Option::None,
            num_blocks: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Extent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Extent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Extent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Extent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.Signatures)
pub struct Signatures {
    // message fields
    // @@protoc_insertion_point(field:chromeos_update_engine.Signatures.signatures)
    pub signatures: ::std::vec::Vec<signatures::Signature>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.Signatures.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Signatures {
    fn default() -> &'a Signatures {
        <Signatures as ::protobuf::Message>::default_instance()
    }
}

impl Signatures {
    pub fn new() -> Signatures {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &Signatures| { &m.signatures },
            |m: &mut Signatures| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Signatures>(
            "Signatures",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Signatures {
    const NAME: &'static str = "Signatures";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.signatures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.signatures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.signatures {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Signatures {
        Signatures::new()
    }

    fn clear(&mut self) {
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Signatures {
        static instance: Signatures = Signatures {
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Signatures {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Signatures").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Signatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signatures {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Signatures`
pub mod signatures {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:chromeos_update_engine.Signatures.Signature)
    pub struct Signature {
        // message fields
        // @@protoc_insertion_point(field:chromeos_update_engine.Signatures.Signature.version)
        pub version: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:chromeos_update_engine.Signatures.Signature.data)
        pub data: ::std::option::Option<::std::vec::Vec<u8>>,
        ///  The DER encoded signature size of EC keys is nondeterministic for
        ///  different input of sha256 hash. However, we need the size of the
        ///  serialized signatures protobuf string to be fixed before signing;
        ///  because this size is part of the content to be signed. Therefore, we
        ///  always pad the signature data to the maximum possible signature size of
        ///  a given key. And the payload verifier will truncate the signature to
        ///  its correct size based on the value of |unpadded_signature_size|.
        // @@protoc_insertion_point(field:chromeos_update_engine.Signatures.Signature.unpadded_signature_size)
        pub unpadded_signature_size: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:chromeos_update_engine.Signatures.Signature.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Signature {
        fn default() -> &'a Signature {
            <Signature as ::protobuf::Message>::default_instance()
        }
    }

    impl Signature {
        pub fn new() -> Signature {
            ::std::default::Default::default()
        }

        // optional uint32 version = 1;

        pub fn version(&self) -> u32 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: u32) {
            self.version = ::std::option::Option::Some(v);
        }

        // optional bytes data = 2;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
            self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional fixed32 unpadded_signature_size = 3;

        pub fn unpadded_signature_size(&self) -> u32 {
            self.unpadded_signature_size.unwrap_or(0)
        }

        pub fn clear_unpadded_signature_size(&mut self) {
            self.unpadded_signature_size = ::std::option::Option::None;
        }

        pub fn has_unpadded_signature_size(&self) -> bool {
            self.unpadded_signature_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unpadded_signature_size(&mut self, v: u32) {
            self.unpadded_signature_size = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &Signature| { &m.version },
                |m: &mut Signature| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &Signature| { &m.data },
                |m: &mut Signature| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unpadded_signature_size",
                |m: &Signature| { &m.unpadded_signature_size },
                |m: &mut Signature| { &mut m.unpadded_signature_size },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Signature>(
                "Signatures.Signature",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Signature {
        const NAME: &'static str = "Signature";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    29 => {
                        self.unpadded_signature_size = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.version {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.unpadded_signature_size {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.version {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.unpadded_signature_size {
                os.write_fixed32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Signature {
            Signature::new()
        }

        fn clear(&mut self) {
            self.version = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.unpadded_signature_size = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Signature {
            static instance: Signature = Signature {
                version: ::std::option::Option::None,
                data: ::std::option::Option::None,
                unpadded_signature_size: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Signature {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Signatures.Signature").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Signature {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Signature {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.PartitionInfo)
pub struct PartitionInfo {
    // message fields
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionInfo.size)
    pub size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionInfo.hash)
    pub hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.PartitionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartitionInfo {
    fn default() -> &'a PartitionInfo {
        <PartitionInfo as ::protobuf::Message>::default_instance()
    }
}

impl PartitionInfo {
    pub fn new() -> PartitionInfo {
        ::std::default::Default::default()
    }

    // optional uint64 size = 1;

    pub fn size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional bytes hash = 2;

    pub fn hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &PartitionInfo| { &m.size },
            |m: &mut PartitionInfo| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &PartitionInfo| { &m.hash },
            |m: &mut PartitionInfo| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartitionInfo>(
            "PartitionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartitionInfo {
    const NAME: &'static str = "PartitionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.size = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.size {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.hash.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartitionInfo {
        PartitionInfo::new()
    }

    fn clear(&mut self) {
        self.size = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartitionInfo {
        static instance: PartitionInfo = PartitionInfo {
            size: ::std::option::Option::None,
            hash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PartitionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartitionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartitionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.InstallOperation)
pub struct InstallOperation {
    // message fields
    // @@protoc_insertion_point(field:chromeos_update_engine.InstallOperation.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<install_operation::Type>>,
    ///  Only minor version 6 or newer support 64 bits |data_offset| and
    ///  |data_length|, older client will read them as uint32.
    ///  The offset into the delta file (after the protobuf)
    ///  where the data (if any) is stored
    // @@protoc_insertion_point(field:chromeos_update_engine.InstallOperation.data_offset)
    pub data_offset: ::std::option::Option<u64>,
    ///  The length of the data in the delta file
    // @@protoc_insertion_point(field:chromeos_update_engine.InstallOperation.data_length)
    pub data_length: ::std::option::Option<u64>,
    ///  Ordered list of extents that are read from (if any) and written to.
    // @@protoc_insertion_point(field:chromeos_update_engine.InstallOperation.src_extents)
    pub src_extents: ::std::vec::Vec<Extent>,
    ///  Byte length of src, equal to the number of blocks in src_extents *
    ///  block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
    ///  pass that external program the number of bytes to read from the blocks we
    ///  pass it.  This is not used in any other operation.
    // @@protoc_insertion_point(field:chromeos_update_engine.InstallOperation.src_length)
    pub src_length: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:chromeos_update_engine.InstallOperation.dst_extents)
    pub dst_extents: ::std::vec::Vec<Extent>,
    ///  Byte length of dst, equal to the number of blocks in dst_extents *
    ///  block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
    ///  operation.
    // @@protoc_insertion_point(field:chromeos_update_engine.InstallOperation.dst_length)
    pub dst_length: ::std::option::Option<u64>,
    ///  Optional SHA 256 hash of the blob associated with this operation.
    ///  This is used as a primary validation for http-based downloads and
    ///  as a defense-in-depth validation for https-based downloads. If
    ///  the operation doesn't refer to any blob, this field will have
    ///  zero bytes.
    // @@protoc_insertion_point(field:chromeos_update_engine.InstallOperation.data_sha256_hash)
    pub data_sha256_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  Indicates the SHA 256 hash of the source data referenced in src_extents at
    ///  the time of applying the operation. If present, the update_engine daemon
    ///  MUST read and verify the source data before applying the operation.
    // @@protoc_insertion_point(field:chromeos_update_engine.InstallOperation.src_sha256_hash)
    pub src_sha256_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.InstallOperation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstallOperation {
    fn default() -> &'a InstallOperation {
        <InstallOperation as ::protobuf::Message>::default_instance()
    }
}

impl InstallOperation {
    pub fn new() -> InstallOperation {
        ::std::default::Default::default()
    }

    // required .chromeos_update_engine.InstallOperation.Type type = 1;

    pub fn type_(&self) -> install_operation::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(install_operation::Type::REPLACE),
            None => install_operation::Type::REPLACE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: install_operation::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 data_offset = 2;

    pub fn data_offset(&self) -> u64 {
        self.data_offset.unwrap_or(0)
    }

    pub fn clear_data_offset(&mut self) {
        self.data_offset = ::std::option::Option::None;
    }

    pub fn has_data_offset(&self) -> bool {
        self.data_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_offset(&mut self, v: u64) {
        self.data_offset = ::std::option::Option::Some(v);
    }

    // optional uint64 data_length = 3;

    pub fn data_length(&self) -> u64 {
        self.data_length.unwrap_or(0)
    }

    pub fn clear_data_length(&mut self) {
        self.data_length = ::std::option::Option::None;
    }

    pub fn has_data_length(&self) -> bool {
        self.data_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_length(&mut self, v: u64) {
        self.data_length = ::std::option::Option::Some(v);
    }

    // optional uint64 src_length = 5;

    pub fn src_length(&self) -> u64 {
        self.src_length.unwrap_or(0)
    }

    pub fn clear_src_length(&mut self) {
        self.src_length = ::std::option::Option::None;
    }

    pub fn has_src_length(&self) -> bool {
        self.src_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_length(&mut self, v: u64) {
        self.src_length = ::std::option::Option::Some(v);
    }

    // optional uint64 dst_length = 7;

    pub fn dst_length(&self) -> u64 {
        self.dst_length.unwrap_or(0)
    }

    pub fn clear_dst_length(&mut self) {
        self.dst_length = ::std::option::Option::None;
    }

    pub fn has_dst_length(&self) -> bool {
        self.dst_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_length(&mut self, v: u64) {
        self.dst_length = ::std::option::Option::Some(v);
    }

    // optional bytes data_sha256_hash = 8;

    pub fn data_sha256_hash(&self) -> &[u8] {
        match self.data_sha256_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data_sha256_hash(&mut self) {
        self.data_sha256_hash = ::std::option::Option::None;
    }

    pub fn has_data_sha256_hash(&self) -> bool {
        self.data_sha256_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_sha256_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.data_sha256_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_sha256_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data_sha256_hash.is_none() {
            self.data_sha256_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data_sha256_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_data_sha256_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.data_sha256_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes src_sha256_hash = 9;

    pub fn src_sha256_hash(&self) -> &[u8] {
        match self.src_sha256_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_src_sha256_hash(&mut self) {
        self.src_sha256_hash = ::std::option::Option::None;
    }

    pub fn has_src_sha256_hash(&self) -> bool {
        self.src_sha256_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_sha256_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.src_sha256_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_sha256_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.src_sha256_hash.is_none() {
            self.src_sha256_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.src_sha256_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_sha256_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.src_sha256_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &InstallOperation| { &m.type_ },
            |m: &mut InstallOperation| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_offset",
            |m: &InstallOperation| { &m.data_offset },
            |m: &mut InstallOperation| { &mut m.data_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_length",
            |m: &InstallOperation| { &m.data_length },
            |m: &mut InstallOperation| { &mut m.data_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "src_extents",
            |m: &InstallOperation| { &m.src_extents },
            |m: &mut InstallOperation| { &mut m.src_extents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "src_length",
            |m: &InstallOperation| { &m.src_length },
            |m: &mut InstallOperation| { &mut m.src_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dst_extents",
            |m: &InstallOperation| { &m.dst_extents },
            |m: &mut InstallOperation| { &mut m.dst_extents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_length",
            |m: &InstallOperation| { &m.dst_length },
            |m: &mut InstallOperation| { &mut m.dst_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_sha256_hash",
            |m: &InstallOperation| { &m.data_sha256_hash },
            |m: &mut InstallOperation| { &mut m.data_sha256_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "src_sha256_hash",
            |m: &InstallOperation| { &m.src_sha256_hash },
            |m: &mut InstallOperation| { &mut m.src_sha256_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstallOperation>(
            "InstallOperation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstallOperation {
    const NAME: &'static str = "InstallOperation";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        for v in &self.src_extents {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dst_extents {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.data_offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.data_length = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.src_extents.push(is.read_message()?);
                },
                40 => {
                    self.src_length = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.dst_extents.push(is.read_message()?);
                },
                56 => {
                    self.dst_length = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    self.data_sha256_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.src_sha256_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.data_offset {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.data_length {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        for value in &self.src_extents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.src_length {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        for value in &self.dst_extents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.dst_length {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.data_sha256_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.src_sha256_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.data_offset {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.data_length {
            os.write_uint64(3, v)?;
        }
        for v in &self.src_extents {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.src_length {
            os.write_uint64(5, v)?;
        }
        for v in &self.dst_extents {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.dst_length {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.data_sha256_hash.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.src_sha256_hash.as_ref() {
            os.write_bytes(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstallOperation {
        InstallOperation::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.data_offset = ::std::option::Option::None;
        self.data_length = ::std::option::Option::None;
        self.src_extents.clear();
        self.src_length = ::std::option::Option::None;
        self.dst_extents.clear();
        self.dst_length = ::std::option::Option::None;
        self.data_sha256_hash = ::std::option::Option::None;
        self.src_sha256_hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstallOperation {
        static instance: InstallOperation = InstallOperation {
            type_: ::std::option::Option::None,
            data_offset: ::std::option::Option::None,
            data_length: ::std::option::Option::None,
            src_extents: ::std::vec::Vec::new(),
            src_length: ::std::option::Option::None,
            dst_extents: ::std::vec::Vec::new(),
            dst_length: ::std::option::Option::None,
            data_sha256_hash: ::std::option::Option::None,
            src_sha256_hash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstallOperation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstallOperation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstallOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallOperation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InstallOperation`
pub mod install_operation {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:chromeos_update_engine.InstallOperation.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.REPLACE)
        REPLACE = 0,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.REPLACE_BZ)
        REPLACE_BZ = 1,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.MOVE)
        MOVE = 2,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.BSDIFF)
        BSDIFF = 3,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.SOURCE_COPY)
        SOURCE_COPY = 4,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.SOURCE_BSDIFF)
        SOURCE_BSDIFF = 5,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.REPLACE_XZ)
        REPLACE_XZ = 8,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.ZERO)
        ZERO = 6,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.DISCARD)
        DISCARD = 7,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.BROTLI_BSDIFF)
        BROTLI_BSDIFF = 10,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.PUFFDIFF)
        PUFFDIFF = 9,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.ZUCCHINI)
        ZUCCHINI = 11,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.LZ4DIFF_BSDIFF)
        LZ4DIFF_BSDIFF = 12,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.InstallOperation.Type.LZ4DIFF_PUFFDIFF)
        LZ4DIFF_PUFFDIFF = 13,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::REPLACE),
                1 => ::std::option::Option::Some(Type::REPLACE_BZ),
                2 => ::std::option::Option::Some(Type::MOVE),
                3 => ::std::option::Option::Some(Type::BSDIFF),
                4 => ::std::option::Option::Some(Type::SOURCE_COPY),
                5 => ::std::option::Option::Some(Type::SOURCE_BSDIFF),
                8 => ::std::option::Option::Some(Type::REPLACE_XZ),
                6 => ::std::option::Option::Some(Type::ZERO),
                7 => ::std::option::Option::Some(Type::DISCARD),
                10 => ::std::option::Option::Some(Type::BROTLI_BSDIFF),
                9 => ::std::option::Option::Some(Type::PUFFDIFF),
                11 => ::std::option::Option::Some(Type::ZUCCHINI),
                12 => ::std::option::Option::Some(Type::LZ4DIFF_BSDIFF),
                13 => ::std::option::Option::Some(Type::LZ4DIFF_PUFFDIFF),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::REPLACE,
            Type::REPLACE_BZ,
            Type::MOVE,
            Type::BSDIFF,
            Type::SOURCE_COPY,
            Type::SOURCE_BSDIFF,
            Type::REPLACE_XZ,
            Type::ZERO,
            Type::DISCARD,
            Type::BROTLI_BSDIFF,
            Type::PUFFDIFF,
            Type::ZUCCHINI,
            Type::LZ4DIFF_BSDIFF,
            Type::LZ4DIFF_PUFFDIFF,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("InstallOperation.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Type::REPLACE => 0,
                Type::REPLACE_BZ => 1,
                Type::MOVE => 2,
                Type::BSDIFF => 3,
                Type::SOURCE_COPY => 4,
                Type::SOURCE_BSDIFF => 5,
                Type::REPLACE_XZ => 6,
                Type::ZERO => 7,
                Type::DISCARD => 8,
                Type::BROTLI_BSDIFF => 9,
                Type::PUFFDIFF => 10,
                Type::ZUCCHINI => 11,
                Type::LZ4DIFF_BSDIFF => 12,
                Type::LZ4DIFF_PUFFDIFF => 13,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::REPLACE
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("InstallOperation.Type")
        }
    }
}

///  Hints to VAB snapshot to skip writing some blocks if these blocks are
///  identical to the ones on the source image. The src & dst extents for each
///  CowMergeOperation should be contiguous, and they're a subset of an OTA
///  InstallOperation.
///  During merge time, we need to follow the pre-computed sequence to avoid
///  read after write, similar to the inplace update schema.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.CowMergeOperation)
pub struct CowMergeOperation {
    // message fields
    // @@protoc_insertion_point(field:chromeos_update_engine.CowMergeOperation.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<cow_merge_operation::Type>>,
    // @@protoc_insertion_point(field:chromeos_update_engine.CowMergeOperation.src_extent)
    pub src_extent: ::protobuf::MessageField<Extent>,
    // @@protoc_insertion_point(field:chromeos_update_engine.CowMergeOperation.dst_extent)
    pub dst_extent: ::protobuf::MessageField<Extent>,
    ///  For COW_XOR, source location might be unaligned, so this field is in range
    ///  [0, block_size), representing how much should the src_extent shift toward
    ///  larger block number. If this field is non-zero, then src_extent will
    ///  include 1 extra block in the end, as the merge op actually references the
    ///  first |src_offset| bytes of that extra block. For example, if |dst_extent|
    ///  is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
    ///  Note that |src_extent| contains 1 extra block than the |dst_extent|.
    // @@protoc_insertion_point(field:chromeos_update_engine.CowMergeOperation.src_offset)
    pub src_offset: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.CowMergeOperation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CowMergeOperation {
    fn default() -> &'a CowMergeOperation {
        <CowMergeOperation as ::protobuf::Message>::default_instance()
    }
}

impl CowMergeOperation {
    pub fn new() -> CowMergeOperation {
        ::std::default::Default::default()
    }

    // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;

    pub fn type_(&self) -> cow_merge_operation::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(cow_merge_operation::Type::COW_COPY),
            None => cow_merge_operation::Type::COW_COPY,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: cow_merge_operation::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 src_offset = 4;

    pub fn src_offset(&self) -> u32 {
        self.src_offset.unwrap_or(0)
    }

    pub fn clear_src_offset(&mut self) {
        self.src_offset = ::std::option::Option::None;
    }

    pub fn has_src_offset(&self) -> bool {
        self.src_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_offset(&mut self, v: u32) {
        self.src_offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CowMergeOperation| { &m.type_ },
            |m: &mut CowMergeOperation| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Extent>(
            "src_extent",
            |m: &CowMergeOperation| { &m.src_extent },
            |m: &mut CowMergeOperation| { &mut m.src_extent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Extent>(
            "dst_extent",
            |m: &CowMergeOperation| { &m.dst_extent },
            |m: &mut CowMergeOperation| { &mut m.dst_extent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "src_offset",
            |m: &CowMergeOperation| { &m.src_offset },
            |m: &mut CowMergeOperation| { &mut m.src_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CowMergeOperation>(
            "CowMergeOperation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CowMergeOperation {
    const NAME: &'static str = "CowMergeOperation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.src_extent)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dst_extent)?;
                },
                32 => {
                    self.src_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.src_extent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dst_extent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.src_offset {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.src_extent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.dst_extent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.src_offset {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CowMergeOperation {
        CowMergeOperation::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.src_extent.clear();
        self.dst_extent.clear();
        self.src_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CowMergeOperation {
        static instance: CowMergeOperation = CowMergeOperation {
            type_: ::std::option::Option::None,
            src_extent: ::protobuf::MessageField::none(),
            dst_extent: ::protobuf::MessageField::none(),
            src_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CowMergeOperation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CowMergeOperation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CowMergeOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CowMergeOperation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CowMergeOperation`
pub mod cow_merge_operation {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:chromeos_update_engine.CowMergeOperation.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.CowMergeOperation.Type.COW_COPY)
        COW_COPY = 0,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.CowMergeOperation.Type.COW_XOR)
        COW_XOR = 1,
        // @@protoc_insertion_point(enum_value:chromeos_update_engine.CowMergeOperation.Type.COW_REPLACE)
        COW_REPLACE = 2,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::COW_COPY),
                1 => ::std::option::Option::Some(Type::COW_XOR),
                2 => ::std::option::Option::Some(Type::COW_REPLACE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::COW_COPY,
            Type::COW_XOR,
            Type::COW_REPLACE,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CowMergeOperation.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::COW_COPY
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("CowMergeOperation.Type")
        }
    }
}

///  Describes the update to apply to a single partition.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.PartitionUpdate)
pub struct PartitionUpdate {
    // message fields
    ///  A platform-specific name to identify the partition set being updated. For
    ///  example, in Chrome OS this could be "ROOT" or "KERNEL".
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.partition_name)
    pub partition_name: ::std::option::Option<::std::string::String>,
    ///  Whether this partition carries a filesystem with post-install program that
    ///  must be run to finalize the update process. See also |postinstall_path| and
    ///  |filesystem_type|.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.run_postinstall)
    pub run_postinstall: ::std::option::Option<bool>,
    ///  The path of the executable program to run during the post-install step,
    ///  relative to the root of this filesystem. If not set, the default "postinst"
    ///  will be used. This setting is only used when |run_postinstall| is set and
    ///  true.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.postinstall_path)
    pub postinstall_path: ::std::option::Option<::std::string::String>,
    ///  The filesystem type as passed to the mount(2) syscall when mounting the new
    ///  filesystem to run the post-install program. If not set, a fixed list of
    ///  filesystems will be attempted. This setting is only used if
    ///  |run_postinstall| is set and true.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.filesystem_type)
    pub filesystem_type: ::std::option::Option<::std::string::String>,
    ///  If present, a list of signatures of the new_partition_info.hash signed with
    ///  different keys. If the update_engine daemon requires vendor-signed images
    ///  and has its public key installed, one of the signatures should be valid
    ///  for /postinstall to run.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.new_partition_signature)
    pub new_partition_signature: ::std::vec::Vec<signatures::Signature>,
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.old_partition_info)
    pub old_partition_info: ::protobuf::MessageField<PartitionInfo>,
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.new_partition_info)
    pub new_partition_info: ::protobuf::MessageField<PartitionInfo>,
    ///  The list of operations to be performed to apply this PartitionUpdate. The
    ///  associated operation blobs (in operations[i].data_offset, data_length)
    ///  should be stored contiguously and in the same order.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.operations)
    pub operations: ::std::vec::Vec<InstallOperation>,
    ///  Whether a failure in the postinstall step for this partition should be
    ///  ignored.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.postinstall_optional)
    pub postinstall_optional: ::std::option::Option<bool>,
    ///  The extent for data covered by verity hash tree.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
    pub hash_tree_data_extent: ::protobuf::MessageField<Extent>,
    ///  The extent to store verity hash tree.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
    pub hash_tree_extent: ::protobuf::MessageField<Extent>,
    ///  The hash algorithm used in verity hash tree.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
    pub hash_tree_algorithm: ::std::option::Option<::std::string::String>,
    ///  The salt used for verity hash tree.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
    pub hash_tree_salt: ::std::option::Option<::std::vec::Vec<u8>>,
    ///  The extent for data covered by FEC.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.fec_data_extent)
    pub fec_data_extent: ::protobuf::MessageField<Extent>,
    ///  The extent to store FEC.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.fec_extent)
    pub fec_extent: ::protobuf::MessageField<Extent>,
    ///  The number of FEC roots.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.fec_roots)
    pub fec_roots: ::std::option::Option<u32>,
    ///  Per-partition version used for downgrade detection, added
    ///  as an effort to support partial updates. For most partitions,
    ///  this is the build timestamp.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.version)
    pub version: ::std::option::Option<::std::string::String>,
    ///  A sorted list of CowMergeOperation. When writing cow, we can choose to
    ///  skip writing the raw bytes for these extents. During snapshot merge, the
    ///  bytes will read from the source partitions instead.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.merge_operations)
    pub merge_operations: ::std::vec::Vec<CowMergeOperation>,
    ///  Estimated size for COW image. This is used by libsnapshot
    ///  as a hint. If set to 0, libsnapshot should use alternative
    ///  methods for estimating size.
    // @@protoc_insertion_point(field:chromeos_update_engine.PartitionUpdate.estimate_cow_size)
    pub estimate_cow_size: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.PartitionUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PartitionUpdate {
    fn default() -> &'a PartitionUpdate {
        <PartitionUpdate as ::protobuf::Message>::default_instance()
    }
}

impl PartitionUpdate {
    pub fn new() -> PartitionUpdate {
        ::std::default::Default::default()
    }

    // required string partition_name = 1;

    pub fn partition_name(&self) -> &str {
        match self.partition_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_partition_name(&mut self) {
        self.partition_name = ::std::option::Option::None;
    }

    pub fn has_partition_name(&self) -> bool {
        self.partition_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_name(&mut self, v: ::std::string::String) {
        self.partition_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partition_name(&mut self) -> &mut ::std::string::String {
        if self.partition_name.is_none() {
            self.partition_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.partition_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_partition_name(&mut self) -> ::std::string::String {
        self.partition_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool run_postinstall = 2;

    pub fn run_postinstall(&self) -> bool {
        self.run_postinstall.unwrap_or(false)
    }

    pub fn clear_run_postinstall(&mut self) {
        self.run_postinstall = ::std::option::Option::None;
    }

    pub fn has_run_postinstall(&self) -> bool {
        self.run_postinstall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_run_postinstall(&mut self, v: bool) {
        self.run_postinstall = ::std::option::Option::Some(v);
    }

    // optional string postinstall_path = 3;

    pub fn postinstall_path(&self) -> &str {
        match self.postinstall_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postinstall_path(&mut self) {
        self.postinstall_path = ::std::option::Option::None;
    }

    pub fn has_postinstall_path(&self) -> bool {
        self.postinstall_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postinstall_path(&mut self, v: ::std::string::String) {
        self.postinstall_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postinstall_path(&mut self) -> &mut ::std::string::String {
        if self.postinstall_path.is_none() {
            self.postinstall_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postinstall_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_postinstall_path(&mut self) -> ::std::string::String {
        self.postinstall_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string filesystem_type = 4;

    pub fn filesystem_type(&self) -> &str {
        match self.filesystem_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filesystem_type(&mut self) {
        self.filesystem_type = ::std::option::Option::None;
    }

    pub fn has_filesystem_type(&self) -> bool {
        self.filesystem_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesystem_type(&mut self, v: ::std::string::String) {
        self.filesystem_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filesystem_type(&mut self) -> &mut ::std::string::String {
        if self.filesystem_type.is_none() {
            self.filesystem_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filesystem_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_filesystem_type(&mut self) -> ::std::string::String {
        self.filesystem_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool postinstall_optional = 9;

    pub fn postinstall_optional(&self) -> bool {
        self.postinstall_optional.unwrap_or(false)
    }

    pub fn clear_postinstall_optional(&mut self) {
        self.postinstall_optional = ::std::option::Option::None;
    }

    pub fn has_postinstall_optional(&self) -> bool {
        self.postinstall_optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postinstall_optional(&mut self, v: bool) {
        self.postinstall_optional = ::std::option::Option::Some(v);
    }

    // optional string hash_tree_algorithm = 12;

    pub fn hash_tree_algorithm(&self) -> &str {
        match self.hash_tree_algorithm.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hash_tree_algorithm(&mut self) {
        self.hash_tree_algorithm = ::std::option::Option::None;
    }

    pub fn has_hash_tree_algorithm(&self) -> bool {
        self.hash_tree_algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash_tree_algorithm(&mut self, v: ::std::string::String) {
        self.hash_tree_algorithm = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_tree_algorithm(&mut self) -> &mut ::std::string::String {
        if self.hash_tree_algorithm.is_none() {
            self.hash_tree_algorithm = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hash_tree_algorithm.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash_tree_algorithm(&mut self) -> ::std::string::String {
        self.hash_tree_algorithm.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes hash_tree_salt = 13;

    pub fn hash_tree_salt(&self) -> &[u8] {
        match self.hash_tree_salt.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hash_tree_salt(&mut self) {
        self.hash_tree_salt = ::std::option::Option::None;
    }

    pub fn has_hash_tree_salt(&self) -> bool {
        self.hash_tree_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash_tree_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash_tree_salt = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_tree_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash_tree_salt.is_none() {
            self.hash_tree_salt = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hash_tree_salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash_tree_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.hash_tree_salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 fec_roots = 16;

    pub fn fec_roots(&self) -> u32 {
        self.fec_roots.unwrap_or(2u32)
    }

    pub fn clear_fec_roots(&mut self) {
        self.fec_roots = ::std::option::Option::None;
    }

    pub fn has_fec_roots(&self) -> bool {
        self.fec_roots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fec_roots(&mut self, v: u32) {
        self.fec_roots = ::std::option::Option::Some(v);
    }

    // optional string version = 17;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 estimate_cow_size = 19;

    pub fn estimate_cow_size(&self) -> u64 {
        self.estimate_cow_size.unwrap_or(0)
    }

    pub fn clear_estimate_cow_size(&mut self) {
        self.estimate_cow_size = ::std::option::Option::None;
    }

    pub fn has_estimate_cow_size(&self) -> bool {
        self.estimate_cow_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimate_cow_size(&mut self, v: u64) {
        self.estimate_cow_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partition_name",
            |m: &PartitionUpdate| { &m.partition_name },
            |m: &mut PartitionUpdate| { &mut m.partition_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "run_postinstall",
            |m: &PartitionUpdate| { &m.run_postinstall },
            |m: &mut PartitionUpdate| { &mut m.run_postinstall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "postinstall_path",
            |m: &PartitionUpdate| { &m.postinstall_path },
            |m: &mut PartitionUpdate| { &mut m.postinstall_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesystem_type",
            |m: &PartitionUpdate| { &m.filesystem_type },
            |m: &mut PartitionUpdate| { &mut m.filesystem_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "new_partition_signature",
            |m: &PartitionUpdate| { &m.new_partition_signature },
            |m: &mut PartitionUpdate| { &mut m.new_partition_signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PartitionInfo>(
            "old_partition_info",
            |m: &PartitionUpdate| { &m.old_partition_info },
            |m: &mut PartitionUpdate| { &mut m.old_partition_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PartitionInfo>(
            "new_partition_info",
            |m: &PartitionUpdate| { &m.new_partition_info },
            |m: &mut PartitionUpdate| { &mut m.new_partition_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "operations",
            |m: &PartitionUpdate| { &m.operations },
            |m: &mut PartitionUpdate| { &mut m.operations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "postinstall_optional",
            |m: &PartitionUpdate| { &m.postinstall_optional },
            |m: &mut PartitionUpdate| { &mut m.postinstall_optional },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Extent>(
            "hash_tree_data_extent",
            |m: &PartitionUpdate| { &m.hash_tree_data_extent },
            |m: &mut PartitionUpdate| { &mut m.hash_tree_data_extent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Extent>(
            "hash_tree_extent",
            |m: &PartitionUpdate| { &m.hash_tree_extent },
            |m: &mut PartitionUpdate| { &mut m.hash_tree_extent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash_tree_algorithm",
            |m: &PartitionUpdate| { &m.hash_tree_algorithm },
            |m: &mut PartitionUpdate| { &mut m.hash_tree_algorithm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash_tree_salt",
            |m: &PartitionUpdate| { &m.hash_tree_salt },
            |m: &mut PartitionUpdate| { &mut m.hash_tree_salt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Extent>(
            "fec_data_extent",
            |m: &PartitionUpdate| { &m.fec_data_extent },
            |m: &mut PartitionUpdate| { &mut m.fec_data_extent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Extent>(
            "fec_extent",
            |m: &PartitionUpdate| { &m.fec_extent },
            |m: &mut PartitionUpdate| { &mut m.fec_extent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fec_roots",
            |m: &PartitionUpdate| { &m.fec_roots },
            |m: &mut PartitionUpdate| { &mut m.fec_roots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &PartitionUpdate| { &m.version },
            |m: &mut PartitionUpdate| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "merge_operations",
            |m: &PartitionUpdate| { &m.merge_operations },
            |m: &mut PartitionUpdate| { &mut m.merge_operations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "estimate_cow_size",
            |m: &PartitionUpdate| { &m.estimate_cow_size },
            |m: &mut PartitionUpdate| { &mut m.estimate_cow_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartitionUpdate>(
            "PartitionUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PartitionUpdate {
    const NAME: &'static str = "PartitionUpdate";

    fn is_initialized(&self) -> bool {
        if self.partition_name.is_none() {
            return false;
        }
        for v in &self.new_partition_signature {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.old_partition_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_partition_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hash_tree_data_extent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hash_tree_extent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fec_data_extent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fec_extent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.merge_operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.partition_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.run_postinstall = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.postinstall_path = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.filesystem_type = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.new_partition_signature.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.old_partition_info)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_partition_info)?;
                },
                66 => {
                    self.operations.push(is.read_message()?);
                },
                72 => {
                    self.postinstall_optional = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hash_tree_data_extent)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hash_tree_extent)?;
                },
                98 => {
                    self.hash_tree_algorithm = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.hash_tree_salt = ::std::option::Option::Some(is.read_bytes()?);
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fec_data_extent)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fec_extent)?;
                },
                128 => {
                    self.fec_roots = ::std::option::Option::Some(is.read_uint32()?);
                },
                138 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.merge_operations.push(is.read_message()?);
                },
                152 => {
                    self.estimate_cow_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.partition_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.run_postinstall {
            my_size += 1 + 1;
        }
        if let Some(v) = self.postinstall_path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.filesystem_type.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.new_partition_signature {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.old_partition_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.new_partition_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.postinstall_optional {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hash_tree_data_extent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hash_tree_extent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hash_tree_algorithm.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.hash_tree_salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(13, &v);
        }
        if let Some(v) = self.fec_data_extent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fec_extent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fec_roots {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        for value in &self.merge_operations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.estimate_cow_size {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.partition_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.run_postinstall {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.postinstall_path.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.filesystem_type.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.new_partition_signature {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.old_partition_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.new_partition_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.operations {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.postinstall_optional {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.hash_tree_data_extent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.hash_tree_extent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.hash_tree_algorithm.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.hash_tree_salt.as_ref() {
            os.write_bytes(13, v)?;
        }
        if let Some(v) = self.fec_data_extent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.fec_extent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.fec_roots {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(17, v)?;
        }
        for v in &self.merge_operations {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.estimate_cow_size {
            os.write_uint64(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PartitionUpdate {
        PartitionUpdate::new()
    }

    fn clear(&mut self) {
        self.partition_name = ::std::option::Option::None;
        self.run_postinstall = ::std::option::Option::None;
        self.postinstall_path = ::std::option::Option::None;
        self.filesystem_type = ::std::option::Option::None;
        self.new_partition_signature.clear();
        self.old_partition_info.clear();
        self.new_partition_info.clear();
        self.operations.clear();
        self.postinstall_optional = ::std::option::Option::None;
        self.hash_tree_data_extent.clear();
        self.hash_tree_extent.clear();
        self.hash_tree_algorithm = ::std::option::Option::None;
        self.hash_tree_salt = ::std::option::Option::None;
        self.fec_data_extent.clear();
        self.fec_extent.clear();
        self.fec_roots = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.merge_operations.clear();
        self.estimate_cow_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PartitionUpdate {
        static instance: PartitionUpdate = PartitionUpdate {
            partition_name: ::std::option::Option::None,
            run_postinstall: ::std::option::Option::None,
            postinstall_path: ::std::option::Option::None,
            filesystem_type: ::std::option::Option::None,
            new_partition_signature: ::std::vec::Vec::new(),
            old_partition_info: ::protobuf::MessageField::none(),
            new_partition_info: ::protobuf::MessageField::none(),
            operations: ::std::vec::Vec::new(),
            postinstall_optional: ::std::option::Option::None,
            hash_tree_data_extent: ::protobuf::MessageField::none(),
            hash_tree_extent: ::protobuf::MessageField::none(),
            hash_tree_algorithm: ::std::option::Option::None,
            hash_tree_salt: ::std::option::Option::None,
            fec_data_extent: ::protobuf::MessageField::none(),
            fec_extent: ::protobuf::MessageField::none(),
            fec_roots: ::std::option::Option::None,
            version: ::std::option::Option::None,
            merge_operations: ::std::vec::Vec::new(),
            estimate_cow_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PartitionUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PartitionUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PartitionUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.DynamicPartitionGroup)
pub struct DynamicPartitionGroup {
    // message fields
    ///  Name of the group.
    // @@protoc_insertion_point(field:chromeos_update_engine.DynamicPartitionGroup.name)
    pub name: ::std::option::Option<::std::string::String>,
    ///  Maximum size of the group. The sum of sizes of all partitions in the group
    ///  must not exceed the maximum size of the group.
    // @@protoc_insertion_point(field:chromeos_update_engine.DynamicPartitionGroup.size)
    pub size: ::std::option::Option<u64>,
    ///  A list of partitions that belong to the group.
    // @@protoc_insertion_point(field:chromeos_update_engine.DynamicPartitionGroup.partition_names)
    pub partition_names: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.DynamicPartitionGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DynamicPartitionGroup {
    fn default() -> &'a DynamicPartitionGroup {
        <DynamicPartitionGroup as ::protobuf::Message>::default_instance()
    }
}

impl DynamicPartitionGroup {
    pub fn new() -> DynamicPartitionGroup {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 size = 2;

    pub fn size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DynamicPartitionGroup| { &m.name },
            |m: &mut DynamicPartitionGroup| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &DynamicPartitionGroup| { &m.size },
            |m: &mut DynamicPartitionGroup| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "partition_names",
            |m: &DynamicPartitionGroup| { &m.partition_names },
            |m: &mut DynamicPartitionGroup| { &mut m.partition_names },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DynamicPartitionGroup>(
            "DynamicPartitionGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DynamicPartitionGroup {
    const NAME: &'static str = "DynamicPartitionGroup";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.size = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.partition_names.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.partition_names {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(2, v)?;
        }
        for v in &self.partition_names {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DynamicPartitionGroup {
        DynamicPartitionGroup::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.partition_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DynamicPartitionGroup {
        static instance: DynamicPartitionGroup = DynamicPartitionGroup {
            name: ::std::option::Option::None,
            size: ::std::option::Option::None,
            partition_names: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DynamicPartitionGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DynamicPartitionGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DynamicPartitionGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicPartitionGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.VABCFeatureSet)
pub struct VABCFeatureSet {
    // message fields
    // @@protoc_insertion_point(field:chromeos_update_engine.VABCFeatureSet.threaded)
    pub threaded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:chromeos_update_engine.VABCFeatureSet.batch_writes)
    pub batch_writes: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.VABCFeatureSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VABCFeatureSet {
    fn default() -> &'a VABCFeatureSet {
        <VABCFeatureSet as ::protobuf::Message>::default_instance()
    }
}

impl VABCFeatureSet {
    pub fn new() -> VABCFeatureSet {
        ::std::default::Default::default()
    }

    // optional bool threaded = 1;

    pub fn threaded(&self) -> bool {
        self.threaded.unwrap_or(false)
    }

    pub fn clear_threaded(&mut self) {
        self.threaded = ::std::option::Option::None;
    }

    pub fn has_threaded(&self) -> bool {
        self.threaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threaded(&mut self, v: bool) {
        self.threaded = ::std::option::Option::Some(v);
    }

    // optional bool batch_writes = 2;

    pub fn batch_writes(&self) -> bool {
        self.batch_writes.unwrap_or(false)
    }

    pub fn clear_batch_writes(&mut self) {
        self.batch_writes = ::std::option::Option::None;
    }

    pub fn has_batch_writes(&self) -> bool {
        self.batch_writes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_batch_writes(&mut self, v: bool) {
        self.batch_writes = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "threaded",
            |m: &VABCFeatureSet| { &m.threaded },
            |m: &mut VABCFeatureSet| { &mut m.threaded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "batch_writes",
            |m: &VABCFeatureSet| { &m.batch_writes },
            |m: &mut VABCFeatureSet| { &mut m.batch_writes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VABCFeatureSet>(
            "VABCFeatureSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VABCFeatureSet {
    const NAME: &'static str = "VABCFeatureSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.threaded = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.batch_writes = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.threaded {
            my_size += 1 + 1;
        }
        if let Some(v) = self.batch_writes {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.threaded {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.batch_writes {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VABCFeatureSet {
        VABCFeatureSet::new()
    }

    fn clear(&mut self) {
        self.threaded = ::std::option::Option::None;
        self.batch_writes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VABCFeatureSet {
        static instance: VABCFeatureSet = VABCFeatureSet {
            threaded: ::std::option::Option::None,
            batch_writes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VABCFeatureSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VABCFeatureSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VABCFeatureSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VABCFeatureSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Metadata related to all dynamic partitions.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.DynamicPartitionMetadata)
pub struct DynamicPartitionMetadata {
    // message fields
    ///  All updatable groups present in |partitions| of this DeltaArchiveManifest.
    ///  - If an updatable group is on the device but not in the manifest, it is
    ///    not updated. Hence, the group will not be resized, and partitions cannot
    ///    be added to or removed from the group.
    ///  - If an updatable group is in the manifest but not on the device, the group
    ///    is added to the device.
    // @@protoc_insertion_point(field:chromeos_update_engine.DynamicPartitionMetadata.groups)
    pub groups: ::std::vec::Vec<DynamicPartitionGroup>,
    ///  Whether dynamic partitions have snapshots during the update. If this is
    ///  set to true, the update_engine daemon creates snapshots for all dynamic
    ///  partitions if possible. If this is unset, the update_engine daemon MUST
    ///  NOT create snapshots for dynamic partitions.
    // @@protoc_insertion_point(field:chromeos_update_engine.DynamicPartitionMetadata.snapshot_enabled)
    pub snapshot_enabled: ::std::option::Option<bool>,
    ///  If this is set to false, update_engine should not use VABC regardless. If
    ///  this is set to true, update_engine may choose to use VABC if device
    ///  supports it, but not guaranteed.
    ///  VABC stands for Virtual AB Compression
    // @@protoc_insertion_point(field:chromeos_update_engine.DynamicPartitionMetadata.vabc_enabled)
    pub vabc_enabled: ::std::option::Option<bool>,
    ///  The compression algorithm used by VABC. Available ones are "gz", "brotli".
    ///  See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
    ///  as this parameter is ultimated forwarded to libsnapshot's CowWriter
    // @@protoc_insertion_point(field:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
    pub vabc_compression_param: ::std::option::Option<::std::string::String>,
    ///  COW version used by VABC. The represents the major version in the COW
    ///  header
    // @@protoc_insertion_point(field:chromeos_update_engine.DynamicPartitionMetadata.cow_version)
    pub cow_version: ::std::option::Option<u32>,
    ///  A collection of knobs to tune Virtual AB Compression
    // @@protoc_insertion_point(field:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
    pub vabc_feature_set: ::protobuf::MessageField<VABCFeatureSet>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.DynamicPartitionMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DynamicPartitionMetadata {
    fn default() -> &'a DynamicPartitionMetadata {
        <DynamicPartitionMetadata as ::protobuf::Message>::default_instance()
    }
}

impl DynamicPartitionMetadata {
    pub fn new() -> DynamicPartitionMetadata {
        ::std::default::Default::default()
    }

    // optional bool snapshot_enabled = 2;

    pub fn snapshot_enabled(&self) -> bool {
        self.snapshot_enabled.unwrap_or(false)
    }

    pub fn clear_snapshot_enabled(&mut self) {
        self.snapshot_enabled = ::std::option::Option::None;
    }

    pub fn has_snapshot_enabled(&self) -> bool {
        self.snapshot_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot_enabled(&mut self, v: bool) {
        self.snapshot_enabled = ::std::option::Option::Some(v);
    }

    // optional bool vabc_enabled = 3;

    pub fn vabc_enabled(&self) -> bool {
        self.vabc_enabled.unwrap_or(false)
    }

    pub fn clear_vabc_enabled(&mut self) {
        self.vabc_enabled = ::std::option::Option::None;
    }

    pub fn has_vabc_enabled(&self) -> bool {
        self.vabc_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vabc_enabled(&mut self, v: bool) {
        self.vabc_enabled = ::std::option::Option::Some(v);
    }

    // optional string vabc_compression_param = 4;

    pub fn vabc_compression_param(&self) -> &str {
        match self.vabc_compression_param.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vabc_compression_param(&mut self) {
        self.vabc_compression_param = ::std::option::Option::None;
    }

    pub fn has_vabc_compression_param(&self) -> bool {
        self.vabc_compression_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vabc_compression_param(&mut self, v: ::std::string::String) {
        self.vabc_compression_param = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vabc_compression_param(&mut self) -> &mut ::std::string::String {
        if self.vabc_compression_param.is_none() {
            self.vabc_compression_param = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vabc_compression_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_vabc_compression_param(&mut self) -> ::std::string::String {
        self.vabc_compression_param.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 cow_version = 5;

    pub fn cow_version(&self) -> u32 {
        self.cow_version.unwrap_or(0)
    }

    pub fn clear_cow_version(&mut self) {
        self.cow_version = ::std::option::Option::None;
    }

    pub fn has_cow_version(&self) -> bool {
        self.cow_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cow_version(&mut self, v: u32) {
        self.cow_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groups",
            |m: &DynamicPartitionMetadata| { &m.groups },
            |m: &mut DynamicPartitionMetadata| { &mut m.groups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "snapshot_enabled",
            |m: &DynamicPartitionMetadata| { &m.snapshot_enabled },
            |m: &mut DynamicPartitionMetadata| { &mut m.snapshot_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vabc_enabled",
            |m: &DynamicPartitionMetadata| { &m.vabc_enabled },
            |m: &mut DynamicPartitionMetadata| { &mut m.vabc_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vabc_compression_param",
            |m: &DynamicPartitionMetadata| { &m.vabc_compression_param },
            |m: &mut DynamicPartitionMetadata| { &mut m.vabc_compression_param },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cow_version",
            |m: &DynamicPartitionMetadata| { &m.cow_version },
            |m: &mut DynamicPartitionMetadata| { &mut m.cow_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VABCFeatureSet>(
            "vabc_feature_set",
            |m: &DynamicPartitionMetadata| { &m.vabc_feature_set },
            |m: &mut DynamicPartitionMetadata| { &mut m.vabc_feature_set },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DynamicPartitionMetadata>(
            "DynamicPartitionMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DynamicPartitionMetadata {
    const NAME: &'static str = "DynamicPartitionMetadata";

    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vabc_feature_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groups.push(is.read_message()?);
                },
                16 => {
                    self.snapshot_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.vabc_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.vabc_compression_param = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.cow_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vabc_feature_set)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.snapshot_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vabc_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vabc_compression_param.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.cow_version {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.vabc_feature_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.groups {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.snapshot_enabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.vabc_enabled {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.vabc_compression_param.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.cow_version {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.vabc_feature_set.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DynamicPartitionMetadata {
        DynamicPartitionMetadata::new()
    }

    fn clear(&mut self) {
        self.groups.clear();
        self.snapshot_enabled = ::std::option::Option::None;
        self.vabc_enabled = ::std::option::Option::None;
        self.vabc_compression_param = ::std::option::Option::None;
        self.cow_version = ::std::option::Option::None;
        self.vabc_feature_set.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DynamicPartitionMetadata {
        static instance: DynamicPartitionMetadata = DynamicPartitionMetadata {
            groups: ::std::vec::Vec::new(),
            snapshot_enabled: ::std::option::Option::None,
            vabc_enabled: ::std::option::Option::None,
            vabc_compression_param: ::std::option::Option::None,
            cow_version: ::std::option::Option::None,
            vabc_feature_set: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DynamicPartitionMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DynamicPartitionMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DynamicPartitionMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicPartitionMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Definition has been duplicated from
///  $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.ApexInfo)
pub struct ApexInfo {
    // message fields
    // @@protoc_insertion_point(field:chromeos_update_engine.ApexInfo.package_name)
    pub package_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:chromeos_update_engine.ApexInfo.version)
    pub version: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:chromeos_update_engine.ApexInfo.is_compressed)
    pub is_compressed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:chromeos_update_engine.ApexInfo.decompressed_size)
    pub decompressed_size: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.ApexInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApexInfo {
    fn default() -> &'a ApexInfo {
        <ApexInfo as ::protobuf::Message>::default_instance()
    }
}

impl ApexInfo {
    pub fn new() -> ApexInfo {
        ::std::default::Default::default()
    }

    // optional string package_name = 1;

    pub fn package_name(&self) -> &str {
        match self.package_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_package_name(&mut self) {
        self.package_name = ::std::option::Option::None;
    }

    pub fn has_package_name(&self) -> bool {
        self.package_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_name(&mut self, v: ::std::string::String) {
        self.package_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package_name(&mut self) -> &mut ::std::string::String {
        if self.package_name.is_none() {
            self.package_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.package_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_package_name(&mut self) -> ::std::string::String {
        self.package_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 version = 2;

    pub fn version(&self) -> i64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bool is_compressed = 3;

    pub fn is_compressed(&self) -> bool {
        self.is_compressed.unwrap_or(false)
    }

    pub fn clear_is_compressed(&mut self) {
        self.is_compressed = ::std::option::Option::None;
    }

    pub fn has_is_compressed(&self) -> bool {
        self.is_compressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_compressed(&mut self, v: bool) {
        self.is_compressed = ::std::option::Option::Some(v);
    }

    // optional int64 decompressed_size = 4;

    pub fn decompressed_size(&self) -> i64 {
        self.decompressed_size.unwrap_or(0)
    }

    pub fn clear_decompressed_size(&mut self) {
        self.decompressed_size = ::std::option::Option::None;
    }

    pub fn has_decompressed_size(&self) -> bool {
        self.decompressed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decompressed_size(&mut self, v: i64) {
        self.decompressed_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "package_name",
            |m: &ApexInfo| { &m.package_name },
            |m: &mut ApexInfo| { &mut m.package_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &ApexInfo| { &m.version },
            |m: &mut ApexInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_compressed",
            |m: &ApexInfo| { &m.is_compressed },
            |m: &mut ApexInfo| { &mut m.is_compressed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decompressed_size",
            |m: &ApexInfo| { &m.decompressed_size },
            |m: &mut ApexInfo| { &mut m.decompressed_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApexInfo>(
            "ApexInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApexInfo {
    const NAME: &'static str = "ApexInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.package_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.is_compressed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.decompressed_size = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.package_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.is_compressed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.decompressed_size {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.package_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.is_compressed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.decompressed_size {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApexInfo {
        ApexInfo::new()
    }

    fn clear(&mut self) {
        self.package_name = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.is_compressed = ::std::option::Option::None;
        self.decompressed_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApexInfo {
        static instance: ApexInfo = ApexInfo {
            package_name: ::std::option::Option::None,
            version: ::std::option::Option::None,
            is_compressed: ::std::option::Option::None,
            decompressed_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApexInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApexInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApexInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApexInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Definition has been duplicated from
///  $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.ApexMetadata)
pub struct ApexMetadata {
    // message fields
    // @@protoc_insertion_point(field:chromeos_update_engine.ApexMetadata.apex_info)
    pub apex_info: ::std::vec::Vec<ApexInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.ApexMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApexMetadata {
    fn default() -> &'a ApexMetadata {
        <ApexMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ApexMetadata {
    pub fn new() -> ApexMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apex_info",
            |m: &ApexMetadata| { &m.apex_info },
            |m: &mut ApexMetadata| { &mut m.apex_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApexMetadata>(
            "ApexMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApexMetadata {
    const NAME: &'static str = "ApexMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apex_info.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apex_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.apex_info {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApexMetadata {
        ApexMetadata::new()
    }

    fn clear(&mut self) {
        self.apex_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApexMetadata {
        static instance: ApexMetadata = ApexMetadata {
            apex_info: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApexMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApexMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApexMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApexMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:chromeos_update_engine.DeltaArchiveManifest)
pub struct DeltaArchiveManifest {
    // message fields
    ///  (At time of writing) usually 4096
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.block_size)
    pub block_size: ::std::option::Option<u32>,
    ///  If signatures are present, the offset into the blobs, generally
    ///  tacked onto the end of the file, and the length. We use an offset
    ///  rather than a bool to allow for more flexibility in future file formats.
    ///  If either is absent, it means signatures aren't supported in this
    ///  file.
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
    pub signatures_offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
    pub signatures_size: ::std::option::Option<u64>,
    ///  The minor version, also referred as "delta version", of the payload.
    ///  Minor version 0 is full payload, everything else is delta payload.
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.minor_version)
    pub minor_version: ::std::option::Option<u32>,
    ///  Only present in major version >= 2. List of partitions that will be
    ///  updated, in the order they will be updated. This field replaces the
    ///  |install_operations|, |kernel_install_operations| and the
    ///  |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
    ///  array can have more than two partitions if needed, and they are identified
    ///  by the partition name.
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.partitions)
    pub partitions: ::std::vec::Vec<PartitionUpdate>,
    ///  The maximum timestamp of the OS allowed to apply this payload.
    ///  Can be used to prevent downgrading the OS.
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.max_timestamp)
    pub max_timestamp: ::std::option::Option<i64>,
    ///  Metadata related to all dynamic partitions.
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
    pub dynamic_partition_metadata: ::protobuf::MessageField<DynamicPartitionMetadata>,
    ///  If the payload only updates a subset of partitions on the device.
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.partial_update)
    pub partial_update: ::std::option::Option<bool>,
    ///  Information on compressed APEX to figure out how much space is required for
    ///  their decompression
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.apex_info)
    pub apex_info: ::std::vec::Vec<ApexInfo>,
    ///  Security patch level of the device, usually in the format of
    ///  yyyy-mm-dd
    // @@protoc_insertion_point(field:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
    pub security_patch_level: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:chromeos_update_engine.DeltaArchiveManifest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeltaArchiveManifest {
    fn default() -> &'a DeltaArchiveManifest {
        <DeltaArchiveManifest as ::protobuf::Message>::default_instance()
    }
}

impl DeltaArchiveManifest {
    pub fn new() -> DeltaArchiveManifest {
        ::std::default::Default::default()
    }

    // optional uint32 block_size = 3;

    pub fn block_size(&self) -> u32 {
        self.block_size.unwrap_or(4096u32)
    }

    pub fn clear_block_size(&mut self) {
        self.block_size = ::std::option::Option::None;
    }

    pub fn has_block_size(&self) -> bool {
        self.block_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_size(&mut self, v: u32) {
        self.block_size = ::std::option::Option::Some(v);
    }

    // optional uint64 signatures_offset = 4;

    pub fn signatures_offset(&self) -> u64 {
        self.signatures_offset.unwrap_or(0)
    }

    pub fn clear_signatures_offset(&mut self) {
        self.signatures_offset = ::std::option::Option::None;
    }

    pub fn has_signatures_offset(&self) -> bool {
        self.signatures_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signatures_offset(&mut self, v: u64) {
        self.signatures_offset = ::std::option::Option::Some(v);
    }

    // optional uint64 signatures_size = 5;

    pub fn signatures_size(&self) -> u64 {
        self.signatures_size.unwrap_or(0)
    }

    pub fn clear_signatures_size(&mut self) {
        self.signatures_size = ::std::option::Option::None;
    }

    pub fn has_signatures_size(&self) -> bool {
        self.signatures_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signatures_size(&mut self, v: u64) {
        self.signatures_size = ::std::option::Option::Some(v);
    }

    // optional uint32 minor_version = 12;

    pub fn minor_version(&self) -> u32 {
        self.minor_version.unwrap_or(0u32)
    }

    pub fn clear_minor_version(&mut self) {
        self.minor_version = ::std::option::Option::None;
    }

    pub fn has_minor_version(&self) -> bool {
        self.minor_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor_version(&mut self, v: u32) {
        self.minor_version = ::std::option::Option::Some(v);
    }

    // optional int64 max_timestamp = 14;

    pub fn max_timestamp(&self) -> i64 {
        self.max_timestamp.unwrap_or(0)
    }

    pub fn clear_max_timestamp(&mut self) {
        self.max_timestamp = ::std::option::Option::None;
    }

    pub fn has_max_timestamp(&self) -> bool {
        self.max_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_timestamp(&mut self, v: i64) {
        self.max_timestamp = ::std::option::Option::Some(v);
    }

    // optional bool partial_update = 16;

    pub fn partial_update(&self) -> bool {
        self.partial_update.unwrap_or(false)
    }

    pub fn clear_partial_update(&mut self) {
        self.partial_update = ::std::option::Option::None;
    }

    pub fn has_partial_update(&self) -> bool {
        self.partial_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partial_update(&mut self, v: bool) {
        self.partial_update = ::std::option::Option::Some(v);
    }

    // optional string security_patch_level = 18;

    pub fn security_patch_level(&self) -> &str {
        match self.security_patch_level.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_security_patch_level(&mut self) {
        self.security_patch_level = ::std::option::Option::None;
    }

    pub fn has_security_patch_level(&self) -> bool {
        self.security_patch_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_security_patch_level(&mut self, v: ::std::string::String) {
        self.security_patch_level = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_patch_level(&mut self) -> &mut ::std::string::String {
        if self.security_patch_level.is_none() {
            self.security_patch_level = ::std::option::Option::Some(::std::string::String::new());
        }
        self.security_patch_level.as_mut().unwrap()
    }

    // Take field
    pub fn take_security_patch_level(&mut self) -> ::std::string::String {
        self.security_patch_level.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "block_size",
            |m: &DeltaArchiveManifest| { &m.block_size },
            |m: &mut DeltaArchiveManifest| { &mut m.block_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signatures_offset",
            |m: &DeltaArchiveManifest| { &m.signatures_offset },
            |m: &mut DeltaArchiveManifest| { &mut m.signatures_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signatures_size",
            |m: &DeltaArchiveManifest| { &m.signatures_size },
            |m: &mut DeltaArchiveManifest| { &mut m.signatures_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minor_version",
            |m: &DeltaArchiveManifest| { &m.minor_version },
            |m: &mut DeltaArchiveManifest| { &mut m.minor_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "partitions",
            |m: &DeltaArchiveManifest| { &m.partitions },
            |m: &mut DeltaArchiveManifest| { &mut m.partitions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_timestamp",
            |m: &DeltaArchiveManifest| { &m.max_timestamp },
            |m: &mut DeltaArchiveManifest| { &mut m.max_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DynamicPartitionMetadata>(
            "dynamic_partition_metadata",
            |m: &DeltaArchiveManifest| { &m.dynamic_partition_metadata },
            |m: &mut DeltaArchiveManifest| { &mut m.dynamic_partition_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partial_update",
            |m: &DeltaArchiveManifest| { &m.partial_update },
            |m: &mut DeltaArchiveManifest| { &mut m.partial_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apex_info",
            |m: &DeltaArchiveManifest| { &m.apex_info },
            |m: &mut DeltaArchiveManifest| { &mut m.apex_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "security_patch_level",
            |m: &DeltaArchiveManifest| { &m.security_patch_level },
            |m: &mut DeltaArchiveManifest| { &mut m.security_patch_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeltaArchiveManifest>(
            "DeltaArchiveManifest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeltaArchiveManifest {
    const NAME: &'static str = "DeltaArchiveManifest";

    fn is_initialized(&self) -> bool {
        for v in &self.partitions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_partition_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apex_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.block_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.signatures_offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.signatures_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.minor_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.partitions.push(is.read_message()?);
                },
                112 => {
                    self.max_timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dynamic_partition_metadata)?;
                },
                128 => {
                    self.partial_update = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.apex_info.push(is.read_message()?);
                },
                146 => {
                    self.security_patch_level = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block_size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.signatures_offset {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.signatures_size {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.minor_version {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        for value in &self.partitions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.max_timestamp {
            my_size += ::protobuf::rt::int64_size(14, v);
        }
        if let Some(v) = self.dynamic_partition_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.partial_update {
            my_size += 2 + 1;
        }
        for value in &self.apex_info {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.security_patch_level.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.signatures_offset {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.signatures_size {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.minor_version {
            os.write_uint32(12, v)?;
        }
        for v in &self.partitions {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.max_timestamp {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.dynamic_partition_metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.partial_update {
            os.write_bool(16, v)?;
        }
        for v in &self.apex_info {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.security_patch_level.as_ref() {
            os.write_string(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeltaArchiveManifest {
        DeltaArchiveManifest::new()
    }

    fn clear(&mut self) {
        self.block_size = ::std::option::Option::None;
        self.signatures_offset = ::std::option::Option::None;
        self.signatures_size = ::std::option::Option::None;
        self.minor_version = ::std::option::Option::None;
        self.partitions.clear();
        self.max_timestamp = ::std::option::Option::None;
        self.dynamic_partition_metadata.clear();
        self.partial_update = ::std::option::Option::None;
        self.apex_info.clear();
        self.security_patch_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeltaArchiveManifest {
        static instance: DeltaArchiveManifest = DeltaArchiveManifest {
            block_size: ::std::option::Option::None,
            signatures_offset: ::std::option::Option::None,
            signatures_size: ::std::option::Option::None,
            minor_version: ::std::option::Option::None,
            partitions: ::std::vec::Vec::new(),
            max_timestamp: ::std::option::Option::None,
            dynamic_partition_metadata: ::protobuf::MessageField::none(),
            partial_update: ::std::option::Option::None,
            apex_info: ::std::vec::Vec::new(),
            security_patch_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeltaArchiveManifest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeltaArchiveManifest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeltaArchiveManifest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeltaArchiveManifest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15update_metadata.proto\x12\x16chromeos_update_engine\"H\n\x06Extent\
    \x12\x1f\n\x0bstart_block\x18\x01\x20\x01(\x04R\nstartBlock\x12\x1d\n\nn\
    um_blocks\x18\x02\x20\x01(\x04R\tnumBlocks\"\xd1\x01\n\nSignatures\x12L\
    \n\nsignatures\x18\x01\x20\x03(\x0b2,.chromeos_update_engine.Signatures.\
    SignatureR\nsignatures\x1au\n\tSignature\x12\x1c\n\x07version\x18\x01\
    \x20\x01(\rR\x07versionB\x02\x18\x01\x12\x12\n\x04data\x18\x02\x20\x01(\
    \x0cR\x04data\x126\n\x17unpadded_signature_size\x18\x03\x20\x01(\x07R\
    \x15unpaddedSignatureSize\"7\n\rPartitionInfo\x12\x12\n\x04size\x18\x01\
    \x20\x01(\x04R\x04size\x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\"\
    \x91\x05\n\x10InstallOperation\x12A\n\x04type\x18\x01\x20\x02(\x0e2-.chr\
    omeos_update_engine.InstallOperation.TypeR\x04type\x12\x1f\n\x0bdata_off\
    set\x18\x02\x20\x01(\x04R\ndataOffset\x12\x1f\n\x0bdata_length\x18\x03\
    \x20\x01(\x04R\ndataLength\x12?\n\x0bsrc_extents\x18\x04\x20\x03(\x0b2\
    \x1e.chromeos_update_engine.ExtentR\nsrcExtents\x12\x1d\n\nsrc_length\
    \x18\x05\x20\x01(\x04R\tsrcLength\x12?\n\x0bdst_extents\x18\x06\x20\x03(\
    \x0b2\x1e.chromeos_update_engine.ExtentR\ndstExtents\x12\x1d\n\ndst_leng\
    th\x18\x07\x20\x01(\x04R\tdstLength\x12(\n\x10data_sha256_hash\x18\x08\
    \x20\x01(\x0cR\x0edataSha256Hash\x12&\n\x0fsrc_sha256_hash\x18\t\x20\x01\
    (\x0cR\rsrcSha256Hash\"\xe5\x01\n\x04Type\x12\x0b\n\x07REPLACE\x10\0\x12\
    \x0e\n\nREPLACE_BZ\x10\x01\x12\x0c\n\x04MOVE\x10\x02\x1a\x02\x08\x01\x12\
    \x0e\n\x06BSDIFF\x10\x03\x1a\x02\x08\x01\x12\x0f\n\x0bSOURCE_COPY\x10\
    \x04\x12\x11\n\rSOURCE_BSDIFF\x10\x05\x12\x0e\n\nREPLACE_XZ\x10\x08\x12\
    \x08\n\x04ZERO\x10\x06\x12\x0b\n\x07DISCARD\x10\x07\x12\x11\n\rBROTLI_BS\
    DIFF\x10\n\x12\x0c\n\x08PUFFDIFF\x10\t\x12\x0c\n\x08ZUCCHINI\x10\x0b\x12\
    \x12\n\x0eLZ4DIFF_BSDIFF\x10\x0c\x12\x14\n\x10LZ4DIFF_PUFFDIFF\x10\r\"\
    \xa8\x02\n\x11CowMergeOperation\x12B\n\x04type\x18\x01\x20\x01(\x0e2..ch\
    romeos_update_engine.CowMergeOperation.TypeR\x04type\x12=\n\nsrc_extent\
    \x18\x02\x20\x01(\x0b2\x1e.chromeos_update_engine.ExtentR\tsrcExtent\x12\
    =\n\ndst_extent\x18\x03\x20\x01(\x0b2\x1e.chromeos_update_engine.ExtentR\
    \tdstExtent\x12\x1d\n\nsrc_offset\x18\x04\x20\x01(\rR\tsrcOffset\"2\n\
    \x04Type\x12\x0c\n\x08COW_COPY\x10\0\x12\x0b\n\x07COW_XOR\x10\x01\x12\
    \x0f\n\x0bCOW_REPLACE\x10\x02\"\xf8\x08\n\x0fPartitionUpdate\x12%\n\x0ep\
    artition_name\x18\x01\x20\x02(\tR\rpartitionName\x12'\n\x0frun_postinsta\
    ll\x18\x02\x20\x01(\x08R\x0erunPostinstall\x12)\n\x10postinstall_path\
    \x18\x03\x20\x01(\tR\x0fpostinstallPath\x12'\n\x0ffilesystem_type\x18\
    \x04\x20\x01(\tR\x0efilesystemType\x12d\n\x17new_partition_signature\x18\
    \x05\x20\x03(\x0b2,.chromeos_update_engine.Signatures.SignatureR\x15newP\
    artitionSignature\x12S\n\x12old_partition_info\x18\x06\x20\x01(\x0b2%.ch\
    romeos_update_engine.PartitionInfoR\x10oldPartitionInfo\x12S\n\x12new_pa\
    rtition_info\x18\x07\x20\x01(\x0b2%.chromeos_update_engine.PartitionInfo\
    R\x10newPartitionInfo\x12H\n\noperations\x18\x08\x20\x03(\x0b2(.chromeos\
    _update_engine.InstallOperationR\noperations\x121\n\x14postinstall_optio\
    nal\x18\t\x20\x01(\x08R\x13postinstallOptional\x12Q\n\x15hash_tree_data_\
    extent\x18\n\x20\x01(\x0b2\x1e.chromeos_update_engine.ExtentR\x12hashTre\
    eDataExtent\x12H\n\x10hash_tree_extent\x18\x0b\x20\x01(\x0b2\x1e.chromeo\
    s_update_engine.ExtentR\x0ehashTreeExtent\x12.\n\x13hash_tree_algorithm\
    \x18\x0c\x20\x01(\tR\x11hashTreeAlgorithm\x12$\n\x0ehash_tree_salt\x18\r\
    \x20\x01(\x0cR\x0chashTreeSalt\x12F\n\x0ffec_data_extent\x18\x0e\x20\x01\
    (\x0b2\x1e.chromeos_update_engine.ExtentR\rfecDataExtent\x12=\n\nfec_ext\
    ent\x18\x0f\x20\x01(\x0b2\x1e.chromeos_update_engine.ExtentR\tfecExtent\
    \x12\x1e\n\tfec_roots\x18\x10\x20\x01(\r:\x012R\x08fecRoots\x12\x18\n\
    \x07version\x18\x11\x20\x01(\tR\x07version\x12T\n\x10merge_operations\
    \x18\x12\x20\x03(\x0b2).chromeos_update_engine.CowMergeOperationR\x0fmer\
    geOperations\x12*\n\x11estimate_cow_size\x18\x13\x20\x01(\x04R\x0festima\
    teCowSize\"h\n\x15DynamicPartitionGroup\x12\x12\n\x04name\x18\x01\x20\
    \x02(\tR\x04name\x12\x12\n\x04size\x18\x02\x20\x01(\x04R\x04size\x12'\n\
    \x0fpartition_names\x18\x03\x20\x03(\tR\x0epartitionNames\"O\n\x0eVABCFe\
    atureSet\x12\x1a\n\x08threaded\x18\x01\x20\x01(\x08R\x08threaded\x12!\n\
    \x0cbatch_writes\x18\x02\x20\x01(\x08R\x0bbatchWrites\"\xd8\x02\n\x18Dyn\
    amicPartitionMetadata\x12E\n\x06groups\x18\x01\x20\x03(\x0b2-.chromeos_u\
    pdate_engine.DynamicPartitionGroupR\x06groups\x12)\n\x10snapshot_enabled\
    \x18\x02\x20\x01(\x08R\x0fsnapshotEnabled\x12!\n\x0cvabc_enabled\x18\x03\
    \x20\x01(\x08R\x0bvabcEnabled\x124\n\x16vabc_compression_param\x18\x04\
    \x20\x01(\tR\x14vabcCompressionParam\x12\x1f\n\x0bcow_version\x18\x05\
    \x20\x01(\rR\ncowVersion\x12P\n\x10vabc_feature_set\x18\x06\x20\x01(\x0b\
    2&.chromeos_update_engine.VABCFeatureSetR\x0evabcFeatureSet\"\x99\x01\n\
    \x08ApexInfo\x12!\n\x0cpackage_name\x18\x01\x20\x01(\tR\x0bpackageName\
    \x12\x18\n\x07version\x18\x02\x20\x01(\x03R\x07version\x12#\n\ris_compre\
    ssed\x18\x03\x20\x01(\x08R\x0cisCompressed\x12+\n\x11decompressed_size\
    \x18\x04\x20\x01(\x03R\x10decompressedSize\"M\n\x0cApexMetadata\x12=\n\t\
    apex_info\x18\x01\x20\x03(\x0b2\x20.chromeos_update_engine.ApexInfoR\x08\
    apexInfo\"\xdf\x04\n\x14DeltaArchiveManifest\x12#\n\nblock_size\x18\x03\
    \x20\x01(\r:\x044096R\tblockSize\x12+\n\x11signatures_offset\x18\x04\x20\
    \x01(\x04R\x10signaturesOffset\x12'\n\x0fsignatures_size\x18\x05\x20\x01\
    (\x04R\x0esignaturesSize\x12&\n\rminor_version\x18\x0c\x20\x01(\r:\x010R\
    \x0cminorVersion\x12G\n\npartitions\x18\r\x20\x03(\x0b2'.chromeos_update\
    _engine.PartitionUpdateR\npartitions\x12#\n\rmax_timestamp\x18\x0e\x20\
    \x01(\x03R\x0cmaxTimestamp\x12n\n\x1adynamic_partition_metadata\x18\x0f\
    \x20\x01(\x0b20.chromeos_update_engine.DynamicPartitionMetadataR\x18dyna\
    micPartitionMetadata\x12%\n\x0epartial_update\x18\x10\x20\x01(\x08R\rpar\
    tialUpdate\x12=\n\tapex_info\x18\x11\x20\x03(\x0b2\x20.chromeos_update_e\
    ngine.ApexInfoR\x08apexInfo\x120\n\x14security_patch_level\x18\x12\x20\
    \x01(\tR\x12securityPatchLevelJ\x04\x08\x01\x10\x02J\x04\x08\x02\x10\x03\
    J\x04\x08\x06\x10\x07J\x04\x08\x07\x10\x08J\x04\x08\x08\x10\tJ\x04\x08\t\
    \x10\nJ\x04\x08\n\x10\x0bJ\x04\x08\x0b\x10\x0cJ\x8a\xa8\x01\n\x07\x12\
    \x05[\0\xb4\x03\x01\n\xf8\x20\n\x01\x0c\x12\x03[\0\x122\xcd\x04\n\x20Cop\
    yright\x20(C)\x202010\x20The\x20Android\x20Open\x20Source\x20Project\n\n\
    \x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20\
    (the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20e\
    xcept\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20\
    obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n2\xad\x0b\x20Update\x20file\x20format:\x20An\x20update\
    \x20file\x20contains\x20all\x20the\x20operations\x20needed\n\x20to\x20up\
    date\x20a\x20system\x20to\x20a\x20specific\x20version.\x20It\x20can\x20b\
    e\x20a\x20full\x20payload\x20which\n\x20can\x20update\x20from\x20any\x20\
    version,\x20or\x20a\x20delta\x20payload\x20which\x20can\x20only\x20updat\
    e\n\x20from\x20a\x20specific\x20version.\n\x20The\x20update\x20format\
    \x20is\x20represented\x20by\x20this\x20struct\x20pseudocode:\n\x20struct\
    \x20delta_update_file\x20{\n\x20\x20\x20char\x20magic[4]\x20=\x20\"CrAU\
    \";\n\x20\x20\x20uint64\x20file_format_version;\x20\x20//\x20payload\x20\
    major\x20version\n\x20\x20\x20uint64\x20manifest_size;\x20\x20//\x20Size\
    \x20of\x20protobuf\x20DeltaArchiveManifest\n\n\x20\x20\x20//\x20Only\x20\
    present\x20if\x20format_version\x20>=\x202:\n\x20\x20\x20uint32\x20metad\
    ata_signature_size;\n\n\x20\x20\x20//\x20The\x20DeltaArchiveManifest\x20\
    protobuf\x20serialized,\x20not\x20compressed.\n\x20\x20\x20char\x20manif\
    est[manifest_size];\n\n\x20\x20\x20//\x20The\x20signature\x20of\x20the\
    \x20metadata\x20(from\x20the\x20beginning\x20of\x20the\x20payload\x20up\
    \x20to\n\x20\x20\x20//\x20this\x20location,\x20not\x20including\x20the\
    \x20signature\x20itself).\x20This\x20is\x20a\x20serialized\n\x20\x20\x20\
    //\x20Signatures\x20message.\n\x20\x20\x20char\x20metadata_signature_mes\
    sage[metadata_signature_size];\n\n\x20\x20\x20//\x20Data\x20blobs\x20for\
    \x20files,\x20no\x20specific\x20format.\x20The\x20specific\x20offset\n\
    \x20\x20\x20//\x20and\x20length\x20of\x20each\x20data\x20blob\x20is\x20r\
    ecorded\x20in\x20the\x20DeltaArchiveManifest.\n\x20\x20\x20struct\x20{\n\
    \x20\x20\x20\x20\x20char\x20data[];\n\x20\x20\x20}\x20blobs[];\n\n\x20\
    \x20\x20//\x20The\x20signature\x20of\x20the\x20entire\x20payload,\x20eve\
    rything\x20up\x20to\x20this\x20location,\n\x20\x20\x20//\x20except\x20th\
    at\x20metadata_signature_message\x20is\x20skipped\x20to\x20simplify\x20s\
    igning\n\x20\x20\x20//\x20process.\x20These\x20two\x20are\x20not\x20sign\
    ed:\n\x20\x20\x20uint64\x20payload_signatures_message_size;\n\x20\x20\
    \x20//\x20This\x20is\x20a\x20serialized\x20Signatures\x20message.\n\x20\
    \x20\x20char\x20payload_signatures_message[payload_signatures_message_si\
    ze];\n\n\x20};\n2\xcf\x01\x20The\x20DeltaArchiveManifest\x20protobuf\x20\
    is\x20an\x20ordered\x20list\x20of\x20InstallOperation\n\x20objects.\x20T\
    hese\x20objects\x20are\x20stored\x20in\x20a\x20linear\x20array\x20in\x20\
    the\n\x20DeltaArchiveManifest.\x20Each\x20operation\x20is\x20applied\x20\
    in\x20order\x20by\x20the\x20client.\n2Y\x20The\x20DeltaArchiveManifest\
    \x20also\x20contains\x20the\x20initial\x20and\x20final\n\x20checksums\
    \x20for\x20the\x20device.\n2\xc0\x0e\x20The\x20client\x20will\x20perform\
    \x20each\x20InstallOperation\x20in\x20order,\x20beginning\x20even\n\x20b\
    efore\x20the\x20entire\x20delta\x20file\x20is\x20downloaded\x20(but\x20a\
    fter\x20at\x20least\x20the\n\x20protobuf\x20is\x20downloaded).\x20The\
    \x20types\x20of\x20operations\x20are\x20explained:\n\x20-\x20REPLACE:\
    \x20Replace\x20the\x20dst_extents\x20on\x20the\x20drive\x20with\x20the\
    \x20attached\x20data,\n\x20\x20\x20zero\x20padding\x20out\x20to\x20block\
    \x20size.\n\x20-\x20REPLACE_BZ:\x20bzip2-uncompress\x20the\x20attached\
    \x20data\x20and\x20write\x20it\x20into\n\x20\x20\x20dst_extents\x20on\
    \x20the\x20drive,\x20zero\x20padding\x20to\x20block\x20size.\n\x20-\x20M\
    OVE:\x20Copy\x20the\x20data\x20in\x20src_extents\x20to\x20dst_extents.\
    \x20Extents\x20may\x20overlap,\n\x20\x20\x20so\x20it\x20may\x20be\x20des\
    irable\x20to\x20read\x20all\x20src_extents\x20data\x20into\x20memory\x20\
    before\n\x20\x20\x20writing\x20it\x20out.\x20(deprecated)\n\x20-\x20SOUR\
    CE_COPY:\x20Copy\x20the\x20data\x20in\x20src_extents\x20in\x20the\x20old\
    \x20partition\x20to\n\x20\x20\x20dst_extents\x20in\x20the\x20new\x20part\
    ition.\x20There's\x20no\x20overlapping\x20of\x20data\x20because\n\x20\
    \x20\x20the\x20extents\x20are\x20in\x20different\x20partitions.\n\x20-\
    \x20BSDIFF:\x20Read\x20src_length\x20bytes\x20from\x20src_extents\x20int\
    o\x20memory,\x20perform\n\x20\x20\x20bspatch\x20with\x20attached\x20data\
    ,\x20write\x20new\x20data\x20to\x20dst_extents,\x20zero\x20padding\n\x20\
    \x20\x20to\x20block\x20size.\x20(deprecated)\n\x20-\x20SOURCE_BSDIFF:\
    \x20Read\x20the\x20data\x20in\x20src_extents\x20in\x20the\x20old\x20part\
    ition,\x20perform\n\x20\x20\x20bspatch\x20with\x20the\x20attached\x20dat\
    a\x20and\x20write\x20the\x20new\x20data\x20to\x20dst_extents\x20in\x20th\
    e\n\x20\x20\x20new\x20partition.\n\x20-\x20ZERO:\x20Write\x20zeros\x20to\
    \x20the\x20destination\x20dst_extents.\n\x20-\x20DISCARD:\x20Discard\x20\
    the\x20destination\x20dst_extents\x20blocks\x20on\x20the\x20physical\x20\
    medium.\n\x20\x20\x20the\x20data\x20read\x20from\x20those\x20blocks\x20i\
    s\x20undefined.\n\x20-\x20REPLACE_XZ:\x20Replace\x20the\x20dst_extents\
    \x20with\x20the\x20contents\x20of\x20the\x20attached\n\x20\x20\x20xz\x20\
    file\x20after\x20decompression.\x20The\x20xz\x20file\x20should\x20only\
    \x20use\x20crc32\x20or\x20no\x20crc\x20at\n\x20\x20\x20all\x20to\x20be\
    \x20compatible\x20with\x20xz-embedded.\n\x20-\x20PUFFDIFF:\x20Read\x20th\
    e\x20data\x20in\x20src_extents\x20in\x20the\x20old\x20partition,\x20perf\
    orm\n\x20\x20\x20puffpatch\x20with\x20the\x20attached\x20data\x20and\x20\
    write\x20the\x20new\x20data\x20to\x20dst_extents\x20in\n\x20\x20\x20the\
    \x20new\x20partition.\n\n\x20The\x20operations\x20allowed\x20in\x20the\
    \x20payload\x20(supported\x20by\x20the\x20client)\x20depend\x20on\x20the\
    \n\x20major\x20and\x20minor\x20version.\x20See\x20InstallOperation.Type\
    \x20below\x20for\x20details.\n\n\x08\n\x01\x02\x12\x03]\0\x1f\n\x8f\x06\
    \n\x02\x04\0\x12\x04l\0o\x012\x82\x06\x20Data\x20is\x20packed\x20into\
    \x20blocks\x20on\x20disk,\x20always\x20starting\x20from\x20the\x20beginn\
    ing\n\x20of\x20the\x20block.\x20If\x20a\x20file's\x20data\x20is\x20too\
    \x20large\x20for\x20one\x20block,\x20it\x20overflows\n\x20into\x20anothe\
    r\x20block,\x20which\x20may\x20or\x20may\x20not\x20be\x20the\x20followin\
    g\x20block\x20on\x20the\n\x20physical\x20partition.\x20An\x20ordered\x20\
    list\x20of\x20extents\x20is\x20another\n\x20representation\x20of\x20an\
    \x20ordered\x20list\x20of\x20blocks.\x20For\x20example,\x20a\x20file\x20\
    stored\n\x20in\x20blocks\x209,\x2010,\x2011,\x202,\x2018,\x2012\x20(in\
    \x20that\x20order)\x20would\x20be\x20stored\x20in\n\x20extents\x20{\x20{\
    9,\x203},\x20{2,\x201},\x20{18,\x201},\x20{12,\x201}\x20}\x20(in\x20that\
    \x20order).\n\x20In\x20general,\x20files\x20are\x20stored\x20sequentiall\
    y\x20on\x20disk,\x20so\x20it's\x20more\x20efficient\n\x20to\x20use\x20ex\
    tents\x20to\x20encode\x20the\x20block\x20lists\x20(this\x20is\x20effecti\
    vely\n\x20run-length\x20encoding).\n\x20A\x20sentinel\x20value\x20(kuint\
    64max)\x20as\x20the\x20start\x20block\x20denotes\x20a\x20sparse-hole\n\
    \x20in\x20a\x20file\x20whose\x20block-length\x20is\x20specified\x20by\
    \x20num_blocks.\n\n\n\n\x03\x04\0\x01\x12\x03l\x08\x0e\n\x0b\n\x04\x04\0\
    \x02\0\x12\x03m\x02\"\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03m\x02\n\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x03m\x0b\x11\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03m\x12\x1d\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03m\x20!\n\x0b\n\x04\x04\
    \0\x02\x01\x12\x03n\x02!\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03n\x02\n\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03n\x0b\x11\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03n\x12\x1c\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03n\x1f\x20\n\
    \xe9\x05\n\x02\x04\x01\x12\x05}\0\x8c\x01\x012\xdb\x05\x20Signatures:\
    \x20Updates\x20may\x20be\x20signed\x20by\x20the\x20OS\x20vendor.\x20The\
    \x20client\x20verifies\n\x20an\x20update's\x20signature\x20by\x20hashing\
    \x20the\x20entire\x20download.\x20The\x20section\x20of\x20the\n\x20downl\
    oad\x20that\x20contains\x20the\x20signature\x20is\x20at\x20the\x20end\
    \x20of\x20the\x20file,\x20so\x20when\n\x20signing\x20a\x20file,\x20only\
    \x20the\x20part\x20up\x20to\x20the\x20signature\x20part\x20is\x20signed.\
    \n\x20Then,\x20the\x20client\x20looks\x20inside\x20the\x20download's\x20\
    Signatures\x20message\x20for\x20a\n\x20Signature\x20message\x20that\x20i\
    t\x20knows\x20how\x20to\x20handle.\x20Generally,\x20a\x20client\x20will\
    \n\x20only\x20know\x20how\x20to\x20handle\x20one\x20type\x20of\x20signat\
    ure,\x20but\x20an\x20update\x20may\x20contain\n\x20many\x20signatures\
    \x20to\x20support\x20many\x20different\x20types\x20of\x20client.\x20Then\
    \x20client\n\x20selects\x20a\x20Signature\x20message\x20and\x20uses\x20t\
    hat,\x20along\x20with\x20a\x20known\x20public\x20key,\n\x20to\x20verify\
    \x20the\x20download.\x20The\x20public\x20key\x20is\x20expected\x20to\x20\
    be\x20part\x20of\x20the\n\x20client.\n\n\n\n\x03\x04\x01\x01\x12\x03}\
    \x08\x12\n\r\n\x04\x04\x01\x03\0\x12\x05~\x02\x8a\x01\x03\n\x0c\n\x05\
    \x04\x01\x03\0\x01\x12\x03~\n\x13\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x03\
    \x7f\x044\n\x0e\n\x07\x04\x01\x03\0\x02\0\x04\x12\x03\x7f\x04\x0c\n\x0e\
    \n\x07\x04\x01\x03\0\x02\0\x05\x12\x03\x7f\r\x13\n\x0e\n\x07\x04\x01\x03\
    \0\x02\0\x01\x12\x03\x7f\x14\x1b\n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\x12\
    \x03\x7f\x1e\x1f\n\x0e\n\x07\x04\x01\x03\0\x02\0\x08\x12\x03\x7f\x203\n\
    \x0f\n\x08\x04\x01\x03\0\x02\0\x08\x03\x12\x03\x7f!2\n\x0e\n\x06\x04\x01\
    \x03\0\x02\x01\x12\x04\x80\x01\x04\x1c\n\x0f\n\x07\x04\x01\x03\0\x02\x01\
    \x04\x12\x04\x80\x01\x04\x0c\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x05\x12\
    \x04\x80\x01\r\x12\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x01\x12\x04\x80\x01\
    \x13\x17\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x03\x12\x04\x80\x01\x1a\x1b\n\
    \xf1\x03\n\x06\x04\x01\x03\0\x02\x02\x12\x04\x89\x01\x041\x1a\xe0\x03\
    \x20The\x20DER\x20encoded\x20signature\x20size\x20of\x20EC\x20keys\x20is\
    \x20nondeterministic\x20for\n\x20different\x20input\x20of\x20sha256\x20h\
    ash.\x20However,\x20we\x20need\x20the\x20size\x20of\x20the\n\x20serializ\
    ed\x20signatures\x20protobuf\x20string\x20to\x20be\x20fixed\x20before\
    \x20signing;\n\x20because\x20this\x20size\x20is\x20part\x20of\x20the\x20\
    content\x20to\x20be\x20signed.\x20Therefore,\x20we\n\x20always\x20pad\
    \x20the\x20signature\x20data\x20to\x20the\x20maximum\x20possible\x20sign\
    ature\x20size\x20of\n\x20a\x20given\x20key.\x20And\x20the\x20payload\x20\
    verifier\x20will\x20truncate\x20the\x20signature\x20to\n\x20its\x20corre\
    ct\x20size\x20based\x20on\x20the\x20value\x20of\x20|unpadded_signature_s\
    ize|.\n\n\x0f\n\x07\x04\x01\x03\0\x02\x02\x04\x12\x04\x89\x01\x04\x0c\n\
    \x0f\n\x07\x04\x01\x03\0\x02\x02\x05\x12\x04\x89\x01\r\x14\n\x0f\n\x07\
    \x04\x01\x03\0\x02\x02\x01\x12\x04\x89\x01\x15,\n\x0f\n\x07\x04\x01\x03\
    \0\x02\x02\x03\x12\x04\x89\x01/0\n\x0c\n\x04\x04\x01\x02\0\x12\x04\x8b\
    \x01\x02$\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x8b\x01\x02\n\n\r\n\x05\
    \x04\x01\x02\0\x06\x12\x04\x8b\x01\x0b\x14\n\r\n\x05\x04\x01\x02\0\x01\
    \x12\x04\x8b\x01\x15\x1f\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x8b\x01\"#\
    \n\x0c\n\x02\x04\x02\x12\x06\x8e\x01\0\x91\x01\x01\n\x0b\n\x03\x04\x02\
    \x01\x12\x04\x8e\x01\x08\x15\n\x0c\n\x04\x04\x02\x02\0\x12\x04\x8f\x01\
    \x02\x1b\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\x8f\x01\x02\n\n\r\n\x05\x04\
    \x02\x02\0\x05\x12\x04\x8f\x01\x0b\x11\n\r\n\x05\x04\x02\x02\0\x01\x12\
    \x04\x8f\x01\x12\x16\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x8f\x01\x19\x1a\
    \n\x0c\n\x04\x04\x02\x02\x01\x12\x04\x90\x01\x02\x1a\n\r\n\x05\x04\x02\
    \x02\x01\x04\x12\x04\x90\x01\x02\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\
    \x90\x01\x0b\x10\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x90\x01\x11\x15\n\
    \r\n\x05\x04\x02\x02\x01\x03\x12\x04\x90\x01\x18\x19\n\x0c\n\x02\x04\x03\
    \x12\x06\x93\x01\0\xd4\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\x93\x01\
    \x08\x18\n\x0e\n\x04\x04\x03\x04\0\x12\x06\x94\x01\x02\xb0\x01\x03\n\r\n\
    \x05\x04\x03\x04\0\x01\x12\x04\x94\x01\x07\x0b\n?\n\x06\x04\x03\x04\0\
    \x02\0\x12\x04\x95\x01\x04\x10\"/\x20Replace\x20destination\x20extents\
    \x20w/\x20attached\x20data.\n\n\x0f\n\x07\x04\x03\x04\0\x02\0\x01\x12\
    \x04\x95\x01\x04\x0b\n\x0f\n\x07\x04\x03\x04\0\x02\0\x02\x12\x04\x95\x01\
    \x0e\x0f\nG\n\x06\x04\x03\x04\0\x02\x01\x12\x04\x96\x01\x04\x13\"7\x20Re\
    place\x20destination\x20extents\x20w/\x20attached\x20bzipped\x20data.\n\
    \n\x0f\n\x07\x04\x03\x04\0\x02\x01\x01\x12\x04\x96\x01\x04\x0e\n\x0f\n\
    \x07\x04\x03\x04\0\x02\x01\x02\x12\x04\x96\x01\x11\x12\n8\n\x06\x04\x03\
    \x04\0\x02\x02\x12\x04\x97\x01\x04!\"(\x20Move\x20source\x20extents\x20t\
    o\x20target\x20extents.\n\n\x0f\n\x07\x04\x03\x04\0\x02\x02\x01\x12\x04\
    \x97\x01\x04\x08\n\x0f\n\x07\x04\x03\x04\0\x02\x02\x02\x12\x04\x97\x01\
    \x0b\x0c\n\x0f\n\x07\x04\x03\x04\0\x02\x02\x03\x12\x04\x97\x01\r\x20\n\
    \x10\n\x08\x04\x03\x04\0\x02\x02\x03\x01\x12\x04\x97\x01\x0e\x1f\n3\n\
    \x06\x04\x03\x04\0\x02\x03\x12\x04\x98\x01\x04#\"#\x20The\x20data\x20is\
    \x20a\x20bsdiff\x20binary\x20diff.\n\n\x0f\n\x07\x04\x03\x04\0\x02\x03\
    \x01\x12\x04\x98\x01\x04\n\n\x0f\n\x07\x04\x03\x04\0\x02\x03\x02\x12\x04\
    \x98\x01\r\x0e\n\x0f\n\x07\x04\x03\x04\0\x02\x03\x03\x12\x04\x98\x01\x0f\
    \"\n\x10\n\x08\x04\x03\x04\0\x02\x03\x03\x01\x12\x04\x98\x01\x10!\nv\n\
    \x06\x04\x03\x04\0\x02\x04\x12\x04\x9b\x01\x04\x14\x1a>\x20On\x20minor\
    \x20version\x202\x20or\x20newer,\x20these\x20operations\x20are\x20suppor\
    ted:\n\"&\x20Copy\x20from\x20source\x20to\x20target\x20partition\n\n\x0f\
    \n\x07\x04\x03\x04\0\x02\x04\x01\x12\x04\x9b\x01\x04\x0f\n\x0f\n\x07\x04\
    \x03\x04\0\x02\x04\x02\x12\x04\x9b\x01\x12\x13\n=\n\x06\x04\x03\x04\0\
    \x02\x05\x12\x04\x9c\x01\x04\x16\"-\x20Like\x20BSDIFF,\x20but\x20read\
    \x20from\x20source\x20partition\n\n\x0f\n\x07\x04\x03\x04\0\x02\x05\x01\
    \x12\x04\x9c\x01\x04\x11\n\x0f\n\x07\x04\x03\x04\0\x02\x05\x02\x12\x04\
    \x9c\x01\x14\x15\n\xa3\x01\n\x06\x04\x03\x04\0\x02\x06\x12\x04\xa0\x01\
    \x04\x13\x1a_\x20On\x20minor\x20version\x203\x20or\x20newer\x20and\x20on\
    \x20major\x20version\x202\x20or\x20newer,\x20these\n\x20operations\x20ar\
    e\x20supported:\n\"2\x20Replace\x20destination\x20extents\x20w/\x20attac\
    hed\x20xz\x20data.\n\n\x0f\n\x07\x04\x03\x04\0\x02\x06\x01\x12\x04\xa0\
    \x01\x04\x0e\n\x0f\n\x07\x04\x03\x04\0\x02\x06\x02\x12\x04\xa0\x01\x11\
    \x12\nq\n\x06\x04\x03\x04\0\x02\x07\x12\x04\xa3\x01\x04\r\x1a>\x20On\x20\
    minor\x20version\x204\x20or\x20newer,\x20these\x20operations\x20are\x20s\
    upported:\n\"!\x20Write\x20zeros\x20in\x20the\x20destination.\n\n\x0f\n\
    \x07\x04\x03\x04\0\x02\x07\x01\x12\x04\xa3\x01\x04\x08\n\x0f\n\x07\x04\
    \x03\x04\0\x02\x07\x02\x12\x04\xa3\x01\x0b\x0c\nG\n\x06\x04\x03\x04\0\
    \x02\x08\x12\x04\xa4\x01\x04\x10\"7\x20Discard\x20the\x20destination\x20\
    blocks,\x20reading\x20as\x20undefined.\n\n\x0f\n\x07\x04\x03\x04\0\x02\
    \x08\x01\x12\x04\xa4\x01\x04\x0b\n\x0f\n\x07\x04\x03\x04\0\x02\x08\x02\
    \x12\x04\xa4\x01\x0e\x0f\nA\n\x06\x04\x03\x04\0\x02\t\x12\x04\xa5\x01\
    \x04\x17\"1\x20Like\x20SOURCE_BSDIFF,\x20but\x20compressed\x20with\x20br\
    otli.\n\n\x0f\n\x07\x04\x03\x04\0\x02\t\x01\x12\x04\xa5\x01\x04\x11\n\
    \x0f\n\x07\x04\x03\x04\0\x02\t\x02\x12\x04\xa5\x01\x14\x16\nq\n\x06\x04\
    \x03\x04\0\x02\n\x12\x04\xa8\x01\x04\x11\x1a>\x20On\x20minor\x20version\
    \x205\x20or\x20newer,\x20these\x20operations\x20are\x20supported:\n\"!\
    \x20The\x20data\x20is\x20in\x20puffdiff\x20format.\n\n\x0f\n\x07\x04\x03\
    \x04\0\x02\n\x01\x12\x04\xa8\x01\x04\x0c\n\x0f\n\x07\x04\x03\x04\0\x02\n\
    \x02\x12\x04\xa8\x01\x0f\x10\nN\n\x06\x04\x03\x04\0\x02\x0b\x12\x04\xab\
    \x01\x04\x12\x1a>\x20On\x20minor\x20version\x208\x20or\x20newer,\x20thes\
    e\x20operations\x20are\x20supported:\n\n\x0f\n\x07\x04\x03\x04\0\x02\x0b\
    \x01\x12\x04\xab\x01\x04\x0c\n\x0f\n\x07\x04\x03\x04\0\x02\x0b\x02\x12\
    \x04\xab\x01\x0f\x11\nN\n\x06\x04\x03\x04\0\x02\x0c\x12\x04\xae\x01\x04\
    \x18\x1a>\x20On\x20minor\x20version\x209\x20or\x20newer,\x20these\x20ope\
    rations\x20are\x20supported:\n\n\x0f\n\x07\x04\x03\x04\0\x02\x0c\x01\x12\
    \x04\xae\x01\x04\x12\n\x0f\n\x07\x04\x03\x04\0\x02\x0c\x02\x12\x04\xae\
    \x01\x15\x17\n\x0e\n\x06\x04\x03\x04\0\x02\r\x12\x04\xaf\x01\x04\x1a\n\
    \x0f\n\x07\x04\x03\x04\0\x02\r\x01\x12\x04\xaf\x01\x04\x14\n\x0f\n\x07\
    \x04\x03\x04\0\x02\r\x02\x12\x04\xaf\x01\x17\x19\n\x0c\n\x04\x04\x03\x02\
    \0\x12\x04\xb1\x01\x02\x19\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\xb1\x01\
    \x02\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\xb1\x01\x0b\x0f\n\r\n\x05\x04\
    \x03\x02\0\x01\x12\x04\xb1\x01\x10\x14\n\r\n\x05\x04\x03\x02\0\x03\x12\
    \x04\xb1\x01\x17\x18\n\xdf\x01\n\x04\x04\x03\x02\x01\x12\x04\xb7\x01\x02\
    \"\x1a\xd0\x01\x20Only\x20minor\x20version\x206\x20or\x20newer\x20suppor\
    t\x2064\x20bits\x20|data_offset|\x20and\n\x20|data_length|,\x20older\x20\
    client\x20will\x20read\x20them\x20as\x20uint32.\n\x20The\x20offset\x20in\
    to\x20the\x20delta\x20file\x20(after\x20the\x20protobuf)\n\x20where\x20t\
    he\x20data\x20(if\x20any)\x20is\x20stored\n\n\r\n\x05\x04\x03\x02\x01\
    \x04\x12\x04\xb7\x01\x02\n\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\xb7\x01\
    \x0b\x11\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xb7\x01\x12\x1d\n\r\n\x05\
    \x04\x03\x02\x01\x03\x12\x04\xb7\x01\x20!\n8\n\x04\x04\x03\x02\x02\x12\
    \x04\xb9\x01\x02\"\x1a*\x20The\x20length\x20of\x20the\x20data\x20in\x20t\
    he\x20delta\x20file\n\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04\xb9\x01\x02\
    \n\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\xb9\x01\x0b\x11\n\r\n\x05\x04\
    \x03\x02\x02\x01\x12\x04\xb9\x01\x12\x1d\n\r\n\x05\x04\x03\x02\x02\x03\
    \x12\x04\xb9\x01\x20!\nS\n\x04\x04\x03\x02\x03\x12\x04\xbc\x01\x02\"\x1a\
    E\x20Ordered\x20list\x20of\x20extents\x20that\x20are\x20read\x20from\x20\
    (if\x20any)\x20and\x20written\x20to.\n\n\r\n\x05\x04\x03\x02\x03\x04\x12\
    \x04\xbc\x01\x02\n\n\r\n\x05\x04\x03\x02\x03\x06\x12\x04\xbc\x01\x0b\x11\
    \n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xbc\x01\x12\x1d\n\r\n\x05\x04\x03\
    \x02\x03\x03\x12\x04\xbc\x01\x20!\n\x9b\x02\n\x04\x04\x03\x02\x04\x12\
    \x04\xc1\x01\x02!\x1a\x8c\x02\x20Byte\x20length\x20of\x20src,\x20equal\
    \x20to\x20the\x20number\x20of\x20blocks\x20in\x20src_extents\x20*\n\x20b\
    lock_size.\x20It\x20is\x20used\x20for\x20BSDIFF\x20and\x20SOURCE_BSDIFF,\
    \x20because\x20we\x20need\x20to\n\x20pass\x20that\x20external\x20program\
    \x20the\x20number\x20of\x20bytes\x20to\x20read\x20from\x20the\x20blocks\
    \x20we\n\x20pass\x20it.\x20\x20This\x20is\x20not\x20used\x20in\x20any\
    \x20other\x20operation.\n\n\r\n\x05\x04\x03\x02\x04\x04\x12\x04\xc1\x01\
    \x02\n\n\r\n\x05\x04\x03\x02\x04\x05\x12\x04\xc1\x01\x0b\x11\n\r\n\x05\
    \x04\x03\x02\x04\x01\x12\x04\xc1\x01\x12\x1c\n\r\n\x05\x04\x03\x02\x04\
    \x03\x12\x04\xc1\x01\x1f\x20\n\x0c\n\x04\x04\x03\x02\x05\x12\x04\xc3\x01\
    \x02\"\n\r\n\x05\x04\x03\x02\x05\x04\x12\x04\xc3\x01\x02\n\n\r\n\x05\x04\
    \x03\x02\x05\x06\x12\x04\xc3\x01\x0b\x11\n\r\n\x05\x04\x03\x02\x05\x01\
    \x12\x04\xc3\x01\x12\x1d\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\xc3\x01\
    \x20!\n\xa4\x01\n\x04\x04\x03\x02\x06\x12\x04\xc7\x01\x02!\x1a\x95\x01\
    \x20Byte\x20length\x20of\x20dst,\x20equal\x20to\x20the\x20number\x20of\
    \x20blocks\x20in\x20dst_extents\x20*\n\x20block_size.\x20Used\x20for\x20\
    BSDIFF\x20and\x20SOURCE_BSDIFF,\x20but\x20not\x20in\x20any\x20other\n\
    \x20operation.\n\n\r\n\x05\x04\x03\x02\x06\x04\x12\x04\xc7\x01\x02\n\n\r\
    \n\x05\x04\x03\x02\x06\x05\x12\x04\xc7\x01\x0b\x11\n\r\n\x05\x04\x03\x02\
    \x06\x01\x12\x04\xc7\x01\x12\x1c\n\r\n\x05\x04\x03\x02\x06\x03\x12\x04\
    \xc7\x01\x1f\x20\n\xa1\x02\n\x04\x04\x03\x02\x07\x12\x04\xce\x01\x02&\
    \x1a\x92\x02\x20Optional\x20SHA\x20256\x20hash\x20of\x20the\x20blob\x20a\
    ssociated\x20with\x20this\x20operation.\n\x20This\x20is\x20used\x20as\
    \x20a\x20primary\x20validation\x20for\x20http-based\x20downloads\x20and\
    \n\x20as\x20a\x20defense-in-depth\x20validation\x20for\x20https-based\
    \x20downloads.\x20If\n\x20the\x20operation\x20doesn't\x20refer\x20to\x20\
    any\x20blob,\x20this\x20field\x20will\x20have\n\x20zero\x20bytes.\n\n\r\
    \n\x05\x04\x03\x02\x07\x04\x12\x04\xce\x01\x02\n\n\r\n\x05\x04\x03\x02\
    \x07\x05\x12\x04\xce\x01\x0b\x10\n\r\n\x05\x04\x03\x02\x07\x01\x12\x04\
    \xce\x01\x11!\n\r\n\x05\x04\x03\x02\x07\x03\x12\x04\xce\x01$%\n\xea\x01\
    \n\x04\x04\x03\x02\x08\x12\x04\xd3\x01\x02%\x1a\xdb\x01\x20Indicates\x20\
    the\x20SHA\x20256\x20hash\x20of\x20the\x20source\x20data\x20referenced\
    \x20in\x20src_extents\x20at\n\x20the\x20time\x20of\x20applying\x20the\
    \x20operation.\x20If\x20present,\x20the\x20update_engine\x20daemon\n\x20\
    MUST\x20read\x20and\x20verify\x20the\x20source\x20data\x20before\x20appl\
    ying\x20the\x20operation.\n\n\r\n\x05\x04\x03\x02\x08\x04\x12\x04\xd3\
    \x01\x02\n\n\r\n\x05\x04\x03\x02\x08\x05\x12\x04\xd3\x01\x0b\x10\n\r\n\
    \x05\x04\x03\x02\x08\x01\x12\x04\xd3\x01\x11\x20\n\r\n\x05\x04\x03\x02\
    \x08\x03\x12\x04\xd3\x01#$\n\xfe\x02\n\x02\x04\x04\x12\x06\xdc\x01\0\xee\
    \x01\x01\x1a\xef\x02\x20Hints\x20to\x20VAB\x20snapshot\x20to\x20skip\x20\
    writing\x20some\x20blocks\x20if\x20these\x20blocks\x20are\n\x20identical\
    \x20to\x20the\x20ones\x20on\x20the\x20source\x20image.\x20The\x20src\x20\
    &\x20dst\x20extents\x20for\x20each\n\x20CowMergeOperation\x20should\x20b\
    e\x20contiguous,\x20and\x20they're\x20a\x20subset\x20of\x20an\x20OTA\n\
    \x20InstallOperation.\n\x20During\x20merge\x20time,\x20we\x20need\x20to\
    \x20follow\x20the\x20pre-computed\x20sequence\x20to\x20avoid\n\x20read\
    \x20after\x20write,\x20similar\x20to\x20the\x20inplace\x20update\x20sche\
    ma.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xdc\x01\x08\x19\n\x0e\n\x04\x04\
    \x04\x04\0\x12\x06\xdd\x01\x02\xe1\x01\x03\n\r\n\x05\x04\x04\x04\0\x01\
    \x12\x04\xdd\x01\x07\x0b\n\"\n\x06\x04\x04\x04\0\x02\0\x12\x04\xde\x01\
    \x04\x11\"\x12\x20identical\x20blocks\n\n\x0f\n\x07\x04\x04\x04\0\x02\0\
    \x01\x12\x04\xde\x01\x04\x0c\n\x0f\n\x07\x04\x04\x04\0\x02\0\x02\x12\x04\
    \xde\x01\x0f\x10\n=\n\x06\x04\x04\x04\0\x02\x01\x12\x04\xdf\x01\x04\x10\
    \"-\x20used\x20when\x20src/dst\x20blocks\x20are\x20highly\x20similar\n\n\
    \x0f\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x04\xdf\x01\x04\x0b\n\x0f\n\x07\
    \x04\x04\x04\0\x02\x01\x02\x12\x04\xdf\x01\x0e\x0f\n'\n\x06\x04\x04\x04\
    \0\x02\x02\x12\x04\xe0\x01\x04\x14\"\x17\x20Raw\x20replace\x20operation\
    \n\n\x0f\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x04\xe0\x01\x04\x0f\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x02\x02\x12\x04\xe0\x01\x12\x13\n\x0c\n\x04\x04\
    \x04\x02\0\x12\x04\xe2\x01\x02\x19\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\
    \xe2\x01\x02\n\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\xe2\x01\x0b\x0f\n\r\n\
    \x05\x04\x04\x02\0\x01\x12\x04\xe2\x01\x10\x14\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\xe2\x01\x17\x18\n\x0c\n\x04\x04\x04\x02\x01\x12\x04\xe4\x01\
    \x02!\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xe4\x01\x02\n\n\r\n\x05\x04\
    \x04\x02\x01\x06\x12\x04\xe4\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x01\x01\
    \x12\x04\xe4\x01\x12\x1c\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xe4\x01\
    \x1f\x20\n\x0c\n\x04\x04\x04\x02\x02\x12\x04\xe5\x01\x02!\n\r\n\x05\x04\
    \x04\x02\x02\x04\x12\x04\xe5\x01\x02\n\n\r\n\x05\x04\x04\x02\x02\x06\x12\
    \x04\xe5\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\xe5\x01\x12\
    \x1c\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xe5\x01\x1f\x20\n\x96\x04\n\
    \x04\x04\x04\x02\x03\x12\x04\xed\x01\x02!\x1a\x87\x04\x20For\x20COW_XOR,\
    \x20source\x20location\x20might\x20be\x20unaligned,\x20so\x20this\x20fie\
    ld\x20is\x20in\x20range\n\x20[0,\x20block_size),\x20representing\x20how\
    \x20much\x20should\x20the\x20src_extent\x20shift\x20toward\n\x20larger\
    \x20block\x20number.\x20If\x20this\x20field\x20is\x20non-zero,\x20then\
    \x20src_extent\x20will\n\x20include\x201\x20extra\x20block\x20in\x20the\
    \x20end,\x20as\x20the\x20merge\x20op\x20actually\x20references\x20the\n\
    \x20first\x20|src_offset|\x20bytes\x20of\x20that\x20extra\x20block.\x20F\
    or\x20example,\x20if\x20|dst_extent|\n\x20is\x20[10,\x2015],\x20|src_off\
    set|\x20is\x20500,\x20then\x20src_extent\x20might\x20look\x20like\x20[25\
    ,\x2031].\n\x20Note\x20that\x20|src_extent|\x20contains\x201\x20extra\
    \x20block\x20than\x20the\x20|dst_extent|.\n\n\r\n\x05\x04\x04\x02\x03\
    \x04\x12\x04\xed\x01\x02\n\n\r\n\x05\x04\x04\x02\x03\x05\x12\x04\xed\x01\
    \x0b\x11\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xed\x01\x12\x1c\n\r\n\x05\
    \x04\x04\x02\x03\x03\x12\x04\xed\x01\x1f\x20\nD\n\x02\x04\x05\x12\x06\
    \xf1\x01\0\xbe\x02\x01\x1a6\x20Describes\x20the\x20update\x20to\x20apply\
    \x20to\x20a\x20single\x20partition.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\
    \xf1\x01\x08\x17\n\x93\x01\n\x04\x04\x05\x02\0\x12\x04\xf4\x01\x02%\x1a\
    \x84\x01\x20A\x20platform-specific\x20name\x20to\x20identify\x20the\x20p\
    artition\x20set\x20being\x20updated.\x20For\n\x20example,\x20in\x20Chrom\
    e\x20OS\x20this\x20could\x20be\x20\"ROOT\"\x20or\x20\"KERNEL\".\n\n\r\n\
    \x05\x04\x05\x02\0\x04\x12\x04\xf4\x01\x02\n\n\r\n\x05\x04\x05\x02\0\x05\
    \x12\x04\xf4\x01\x0b\x11\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xf4\x01\x12\
    \x20\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xf4\x01#$\n\xbc\x01\n\x04\x04\
    \x05\x02\x01\x12\x04\xf9\x01\x02$\x1a\xad\x01\x20Whether\x20this\x20part\
    ition\x20carries\x20a\x20filesystem\x20with\x20post-install\x20program\
    \x20that\n\x20must\x20be\x20run\x20to\x20finalize\x20the\x20update\x20pr\
    ocess.\x20See\x20also\x20|postinstall_path|\x20and\n\x20|filesystem_type\
    |.\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\xf9\x01\x02\n\n\r\n\x05\x04\
    \x05\x02\x01\x05\x12\x04\xf9\x01\x0b\x0f\n\r\n\x05\x04\x05\x02\x01\x01\
    \x12\x04\xf9\x01\x10\x1f\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xf9\x01\"\
    #\n\xf7\x01\n\x04\x04\x05\x02\x02\x12\x04\xff\x01\x02'\x1a\xe8\x01\x20Th\
    e\x20path\x20of\x20the\x20executable\x20program\x20to\x20run\x20during\
    \x20the\x20post-install\x20step,\n\x20relative\x20to\x20the\x20root\x20o\
    f\x20this\x20filesystem.\x20If\x20not\x20set,\x20the\x20default\x20\"pos\
    tinst\"\n\x20will\x20be\x20used.\x20This\x20setting\x20is\x20only\x20use\
    d\x20when\x20|run_postinstall|\x20is\x20set\x20and\n\x20true.\n\n\r\n\
    \x05\x04\x05\x02\x02\x04\x12\x04\xff\x01\x02\n\n\r\n\x05\x04\x05\x02\x02\
    \x05\x12\x04\xff\x01\x0b\x11\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xff\
    \x01\x12\"\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xff\x01%&\n\x86\x02\n\
    \x04\x04\x05\x02\x03\x12\x04\x85\x02\x02&\x1a\xf7\x01\x20The\x20filesyst\
    em\x20type\x20as\x20passed\x20to\x20the\x20mount(2)\x20syscall\x20when\
    \x20mounting\x20the\x20new\n\x20filesystem\x20to\x20run\x20the\x20post-i\
    nstall\x20program.\x20If\x20not\x20set,\x20a\x20fixed\x20list\x20of\n\
    \x20filesystems\x20will\x20be\x20attempted.\x20This\x20setting\x20is\x20\
    only\x20used\x20if\n\x20|run_postinstall|\x20is\x20set\x20and\x20true.\n\
    \n\r\n\x05\x04\x05\x02\x03\x04\x12\x04\x85\x02\x02\n\n\r\n\x05\x04\x05\
    \x02\x03\x05\x12\x04\x85\x02\x0b\x11\n\r\n\x05\x04\x05\x02\x03\x01\x12\
    \x04\x85\x02\x12!\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\x85\x02$%\n\x8a\
    \x02\n\x04\x04\x05\x02\x04\x12\x04\x8b\x02\x02<\x1a\xfb\x01\x20If\x20pre\
    sent,\x20a\x20list\x20of\x20signatures\x20of\x20the\x20new_partition_inf\
    o.hash\x20signed\x20with\n\x20different\x20keys.\x20If\x20the\x20update_\
    engine\x20daemon\x20requires\x20vendor-signed\x20images\n\x20and\x20has\
    \x20its\x20public\x20key\x20installed,\x20one\x20of\x20the\x20signatures\
    \x20should\x20be\x20valid\n\x20for\x20/postinstall\x20to\x20run.\n\n\r\n\
    \x05\x04\x05\x02\x04\x04\x12\x04\x8b\x02\x02\n\n\r\n\x05\x04\x05\x02\x04\
    \x06\x12\x04\x8b\x02\x0b\x1f\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\x8b\
    \x02\x207\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\x8b\x02:;\n\x0c\n\x04\
    \x04\x05\x02\x05\x12\x04\x8d\x02\x020\n\r\n\x05\x04\x05\x02\x05\x04\x12\
    \x04\x8d\x02\x02\n\n\r\n\x05\x04\x05\x02\x05\x06\x12\x04\x8d\x02\x0b\x18\
    \n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\x8d\x02\x19+\n\r\n\x05\x04\x05\
    \x02\x05\x03\x12\x04\x8d\x02./\n\x0c\n\x04\x04\x05\x02\x06\x12\x04\x8e\
    \x02\x020\n\r\n\x05\x04\x05\x02\x06\x04\x12\x04\x8e\x02\x02\n\n\r\n\x05\
    \x04\x05\x02\x06\x06\x12\x04\x8e\x02\x0b\x18\n\r\n\x05\x04\x05\x02\x06\
    \x01\x12\x04\x8e\x02\x19+\n\r\n\x05\x04\x05\x02\x06\x03\x12\x04\x8e\x02.\
    /\n\xd8\x01\n\x04\x04\x05\x02\x07\x12\x04\x93\x02\x02+\x1a\xc9\x01\x20Th\
    e\x20list\x20of\x20operations\x20to\x20be\x20performed\x20to\x20apply\
    \x20this\x20PartitionUpdate.\x20The\n\x20associated\x20operation\x20blob\
    s\x20(in\x20operations[i].data_offset,\x20data_length)\n\x20should\x20be\
    \x20stored\x20contiguously\x20and\x20in\x20the\x20same\x20order.\n\n\r\n\
    \x05\x04\x05\x02\x07\x04\x12\x04\x93\x02\x02\n\n\r\n\x05\x04\x05\x02\x07\
    \x06\x12\x04\x93\x02\x0b\x1b\n\r\n\x05\x04\x05\x02\x07\x01\x12\x04\x93\
    \x02\x1c&\n\r\n\x05\x04\x05\x02\x07\x03\x12\x04\x93\x02)*\n`\n\x04\x04\
    \x05\x02\x08\x12\x04\x97\x02\x02)\x1aR\x20Whether\x20a\x20failure\x20in\
    \x20the\x20postinstall\x20step\x20for\x20this\x20partition\x20should\x20\
    be\n\x20ignored.\n\n\r\n\x05\x04\x05\x02\x08\x04\x12\x04\x97\x02\x02\n\n\
    \r\n\x05\x04\x05\x02\x08\x05\x12\x04\x97\x02\x0b\x0f\n\r\n\x05\x04\x05\
    \x02\x08\x01\x12\x04\x97\x02\x10$\n\r\n\x05\x04\x05\x02\x08\x03\x12\x04\
    \x97\x02'(\n|\n\x04\x04\x05\x02\t\x12\x04\x9c\x02\x02-\x1a2\x20The\x20ex\
    tent\x20for\x20data\x20covered\x20by\x20verity\x20hash\x20tree.\n2:\x20O\
    n\x20minor\x20version\x206\x20or\x20newer,\x20these\x20fields\x20are\x20\
    supported:\n\n\r\n\x05\x04\x05\x02\t\x04\x12\x04\x9c\x02\x02\n\n\r\n\x05\
    \x04\x05\x02\t\x06\x12\x04\x9c\x02\x0b\x11\n\r\n\x05\x04\x05\x02\t\x01\
    \x12\x04\x9c\x02\x12'\n\r\n\x05\x04\x05\x02\t\x03\x12\x04\x9c\x02*,\n5\n\
    \x04\x04\x05\x02\n\x12\x04\x9f\x02\x02(\x1a'\x20The\x20extent\x20to\x20s\
    tore\x20verity\x20hash\x20tree.\n\n\r\n\x05\x04\x05\x02\n\x04\x12\x04\
    \x9f\x02\x02\n\n\r\n\x05\x04\x05\x02\n\x06\x12\x04\x9f\x02\x0b\x11\n\r\n\
    \x05\x04\x05\x02\n\x01\x12\x04\x9f\x02\x12\"\n\r\n\x05\x04\x05\x02\n\x03\
    \x12\x04\x9f\x02%'\n<\n\x04\x04\x05\x02\x0b\x12\x04\xa2\x02\x02+\x1a.\
    \x20The\x20hash\x20algorithm\x20used\x20in\x20verity\x20hash\x20tree.\n\
    \n\r\n\x05\x04\x05\x02\x0b\x04\x12\x04\xa2\x02\x02\n\n\r\n\x05\x04\x05\
    \x02\x0b\x05\x12\x04\xa2\x02\x0b\x11\n\r\n\x05\x04\x05\x02\x0b\x01\x12\
    \x04\xa2\x02\x12%\n\r\n\x05\x04\x05\x02\x0b\x03\x12\x04\xa2\x02(*\n3\n\
    \x04\x04\x05\x02\x0c\x12\x04\xa5\x02\x02%\x1a%\x20The\x20salt\x20used\
    \x20for\x20verity\x20hash\x20tree.\n\n\r\n\x05\x04\x05\x02\x0c\x04\x12\
    \x04\xa5\x02\x02\n\n\r\n\x05\x04\x05\x02\x0c\x05\x12\x04\xa5\x02\x0b\x10\
    \n\r\n\x05\x04\x05\x02\x0c\x01\x12\x04\xa5\x02\x11\x1f\n\r\n\x05\x04\x05\
    \x02\x0c\x03\x12\x04\xa5\x02\"$\n3\n\x04\x04\x05\x02\r\x12\x04\xa8\x02\
    \x02'\x1a%\x20The\x20extent\x20for\x20data\x20covered\x20by\x20FEC.\n\n\
    \r\n\x05\x04\x05\x02\r\x04\x12\x04\xa8\x02\x02\n\n\r\n\x05\x04\x05\x02\r\
    \x06\x12\x04\xa8\x02\x0b\x11\n\r\n\x05\x04\x05\x02\r\x01\x12\x04\xa8\x02\
    \x12!\n\r\n\x05\x04\x05\x02\r\x03\x12\x04\xa8\x02$&\n(\n\x04\x04\x05\x02\
    \x0e\x12\x04\xab\x02\x02\"\x1a\x1a\x20The\x20extent\x20to\x20store\x20FE\
    C.\n\n\r\n\x05\x04\x05\x02\x0e\x04\x12\x04\xab\x02\x02\n\n\r\n\x05\x04\
    \x05\x02\x0e\x06\x12\x04\xab\x02\x0b\x11\n\r\n\x05\x04\x05\x02\x0e\x01\
    \x12\x04\xab\x02\x12\x1c\n\r\n\x05\x04\x05\x02\x0e\x03\x12\x04\xab\x02\
    \x1f!\n(\n\x04\x04\x05\x02\x0f\x12\x04\xae\x02\x02/\x1a\x1a\x20The\x20nu\
    mber\x20of\x20FEC\x20roots.\n\n\r\n\x05\x04\x05\x02\x0f\x04\x12\x04\xae\
    \x02\x02\n\n\r\n\x05\x04\x05\x02\x0f\x05\x12\x04\xae\x02\x0b\x11\n\r\n\
    \x05\x04\x05\x02\x0f\x01\x12\x04\xae\x02\x12\x1b\n\r\n\x05\x04\x05\x02\
    \x0f\x03\x12\x04\xae\x02\x1e\x20\n\r\n\x05\x04\x05\x02\x0f\x08\x12\x04\
    \xae\x02!.\n\r\n\x05\x04\x05\x02\x0f\x07\x12\x04\xae\x02,-\n\xa7\x01\n\
    \x04\x04\x05\x02\x10\x12\x04\xb3\x02\x02\x1f\x1a\x98\x01\x20Per-partitio\
    n\x20version\x20used\x20for\x20downgrade\x20detection,\x20added\n\x20as\
    \x20an\x20effort\x20to\x20support\x20partial\x20updates.\x20For\x20most\
    \x20partitions,\n\x20this\x20is\x20the\x20build\x20timestamp.\n\n\r\n\
    \x05\x04\x05\x02\x10\x04\x12\x04\xb3\x02\x02\n\n\r\n\x05\x04\x05\x02\x10\
    \x05\x12\x04\xb3\x02\x0b\x11\n\r\n\x05\x04\x05\x02\x10\x01\x12\x04\xb3\
    \x02\x12\x19\n\r\n\x05\x04\x05\x02\x10\x03\x12\x04\xb3\x02\x1c\x1e\n\xd6\
    \x01\n\x04\x04\x05\x02\x11\x12\x04\xb8\x02\x023\x1a\xc7\x01\x20A\x20sort\
    ed\x20list\x20of\x20CowMergeOperation.\x20When\x20writing\x20cow,\x20we\
    \x20can\x20choose\x20to\n\x20skip\x20writing\x20the\x20raw\x20bytes\x20f\
    or\x20these\x20extents.\x20During\x20snapshot\x20merge,\x20the\n\x20byte\
    s\x20will\x20read\x20from\x20the\x20source\x20partitions\x20instead.\n\n\
    \r\n\x05\x04\x05\x02\x11\x04\x12\x04\xb8\x02\x02\n\n\r\n\x05\x04\x05\x02\
    \x11\x06\x12\x04\xb8\x02\x0b\x1c\n\r\n\x05\x04\x05\x02\x11\x01\x12\x04\
    \xb8\x02\x1d-\n\r\n\x05\x04\x05\x02\x11\x03\x12\x04\xb8\x0202\n\xa4\x01\
    \n\x04\x04\x05\x02\x12\x12\x04\xbd\x02\x02)\x1a\x95\x01\x20Estimated\x20\
    size\x20for\x20COW\x20image.\x20This\x20is\x20used\x20by\x20libsnapshot\
    \n\x20as\x20a\x20hint.\x20If\x20set\x20to\x200,\x20libsnapshot\x20should\
    \x20use\x20alternative\n\x20methods\x20for\x20estimating\x20size.\n\n\r\
    \n\x05\x04\x05\x02\x12\x04\x12\x04\xbd\x02\x02\n\n\r\n\x05\x04\x05\x02\
    \x12\x05\x12\x04\xbd\x02\x0b\x11\n\r\n\x05\x04\x05\x02\x12\x01\x12\x04\
    \xbd\x02\x12#\n\r\n\x05\x04\x05\x02\x12\x03\x12\x04\xbd\x02&(\n\x0c\n\
    \x02\x04\x06\x12\x06\xc0\x02\0\xca\x02\x01\n\x0b\n\x03\x04\x06\x01\x12\
    \x04\xc0\x02\x08\x1d\n\"\n\x04\x04\x06\x02\0\x12\x04\xc2\x02\x02\x1b\x1a\
    \x14\x20Name\x20of\x20the\x20group.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\
    \x04\xc2\x02\x02\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xc2\x02\x0b\x11\n\
    \r\n\x05\x04\x06\x02\0\x01\x12\x04\xc2\x02\x12\x16\n\r\n\x05\x04\x06\x02\
    \0\x03\x12\x04\xc2\x02\x19\x1a\n\x8a\x01\n\x04\x04\x06\x02\x01\x12\x04\
    \xc6\x02\x02\x1b\x1a|\x20Maximum\x20size\x20of\x20the\x20group.\x20The\
    \x20sum\x20of\x20sizes\x20of\x20all\x20partitions\x20in\x20the\x20group\
    \n\x20must\x20not\x20exceed\x20the\x20maximum\x20size\x20of\x20the\x20gr\
    oup.\n\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xc6\x02\x02\n\n\r\n\x05\x04\
    \x06\x02\x01\x05\x12\x04\xc6\x02\x0b\x11\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xc6\x02\x12\x16\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xc6\x02\
    \x19\x1a\n>\n\x04\x04\x06\x02\x02\x12\x04\xc9\x02\x02&\x1a0\x20A\x20list\
    \x20of\x20partitions\x20that\x20belong\x20to\x20the\x20group.\n\n\r\n\
    \x05\x04\x06\x02\x02\x04\x12\x04\xc9\x02\x02\n\n\r\n\x05\x04\x06\x02\x02\
    \x05\x12\x04\xc9\x02\x0b\x11\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xc9\
    \x02\x12!\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xc9\x02$%\n\x0c\n\x02\
    \x04\x07\x12\x06\xcc\x02\0\xcf\x02\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\
    \xcc\x02\x08\x16\n\x0c\n\x04\x04\x07\x02\0\x12\x04\xcd\x02\x02\x1d\n\r\n\
    \x05\x04\x07\x02\0\x04\x12\x04\xcd\x02\x02\n\n\r\n\x05\x04\x07\x02\0\x05\
    \x12\x04\xcd\x02\x0b\x0f\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xcd\x02\x10\
    \x18\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xcd\x02\x1b\x1c\n\x0c\n\x04\x04\
    \x07\x02\x01\x12\x04\xce\x02\x02!\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\
    \xce\x02\x02\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xce\x02\x0b\x0f\n\r\
    \n\x05\x04\x07\x02\x01\x01\x12\x04\xce\x02\x10\x1c\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\xce\x02\x1f\x20\n;\n\x02\x04\x08\x12\x06\xd2\x02\0\xf2\
    \x02\x01\x1a-\x20Metadata\x20related\x20to\x20all\x20dynamic\x20partitio\
    ns.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xd2\x02\x08\x20\n\x82\x03\n\x04\
    \x04\x08\x02\0\x12\x04\xd9\x02\x02,\x1a\xf3\x02\x20All\x20updatable\x20g\
    roups\x20present\x20in\x20|partitions|\x20of\x20this\x20DeltaArchiveMani\
    fest.\n\x20-\x20If\x20an\x20updatable\x20group\x20is\x20on\x20the\x20dev\
    ice\x20but\x20not\x20in\x20the\x20manifest,\x20it\x20is\n\x20\x20\x20not\
    \x20updated.\x20Hence,\x20the\x20group\x20will\x20not\x20be\x20resized,\
    \x20and\x20partitions\x20cannot\n\x20\x20\x20be\x20added\x20to\x20or\x20\
    removed\x20from\x20the\x20group.\n\x20-\x20If\x20an\x20updatable\x20grou\
    p\x20is\x20in\x20the\x20manifest\x20but\x20not\x20on\x20the\x20device,\
    \x20the\x20group\n\x20\x20\x20is\x20added\x20to\x20the\x20device.\n\n\r\
    \n\x05\x04\x08\x02\0\x04\x12\x04\xd9\x02\x02\n\n\r\n\x05\x04\x08\x02\0\
    \x06\x12\x04\xd9\x02\x0b\x20\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xd9\x02\
    !'\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xd9\x02*+\n\x98\x02\n\x04\x04\x08\
    \x02\x01\x12\x04\xdf\x02\x02%\x1a\x89\x02\x20Whether\x20dynamic\x20parti\
    tions\x20have\x20snapshots\x20during\x20the\x20update.\x20If\x20this\x20\
    is\n\x20set\x20to\x20true,\x20the\x20update_engine\x20daemon\x20creates\
    \x20snapshots\x20for\x20all\x20dynamic\n\x20partitions\x20if\x20possible\
    .\x20If\x20this\x20is\x20unset,\x20the\x20update_engine\x20daemon\x20MUS\
    T\n\x20NOT\x20create\x20snapshots\x20for\x20dynamic\x20partitions.\n\n\r\
    \n\x05\x04\x08\x02\x01\x04\x12\x04\xdf\x02\x02\n\n\r\n\x05\x04\x08\x02\
    \x01\x05\x12\x04\xdf\x02\x0b\x0f\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\
    \xdf\x02\x10\x20\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xdf\x02#$\n\xe9\
    \x01\n\x04\x04\x08\x02\x02\x12\x04\xe5\x02\x02!\x1a\xda\x01\x20If\x20thi\
    s\x20is\x20set\x20to\x20false,\x20update_engine\x20should\x20not\x20use\
    \x20VABC\x20regardless.\x20If\n\x20this\x20is\x20set\x20to\x20true,\x20u\
    pdate_engine\x20may\x20choose\x20to\x20use\x20VABC\x20if\x20device\n\x20\
    supports\x20it,\x20but\x20not\x20guaranteed.\n\x20VABC\x20stands\x20for\
    \x20Virtual\x20AB\x20Compression\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\
    \xe5\x02\x02\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xe5\x02\x0b\x0f\n\r\
    \n\x05\x04\x08\x02\x02\x01\x12\x04\xe5\x02\x10\x1c\n\r\n\x05\x04\x08\x02\
    \x02\x03\x12\x04\xe5\x02\x1f\x20\n\xea\x01\n\x04\x04\x08\x02\x03\x12\x04\
    \xea\x02\x02-\x1a\xdb\x01\x20The\x20compression\x20algorithm\x20used\x20\
    by\x20VABC.\x20Available\x20ones\x20are\x20\"gz\",\x20\"brotli\".\n\x20S\
    ee\x20system/core/fs_mgr/libsnapshot/cow_writer.cpp\x20for\x20available\
    \x20options,\n\x20as\x20this\x20parameter\x20is\x20ultimated\x20forwarde\
    d\x20to\x20libsnapshot's\x20CowWriter\n\n\r\n\x05\x04\x08\x02\x03\x04\
    \x12\x04\xea\x02\x02\n\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\xea\x02\x0b\
    \x11\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xea\x02\x12(\n\r\n\x05\x04\
    \x08\x02\x03\x03\x12\x04\xea\x02+,\n]\n\x04\x04\x08\x02\x04\x12\x04\xee\
    \x02\x02\"\x1aO\x20COW\x20version\x20used\x20by\x20VABC.\x20The\x20repre\
    sents\x20the\x20major\x20version\x20in\x20the\x20COW\n\x20header\n\n\r\n\
    \x05\x04\x08\x02\x04\x04\x12\x04\xee\x02\x02\n\n\r\n\x05\x04\x08\x02\x04\
    \x05\x12\x04\xee\x02\x0b\x11\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\xee\
    \x02\x12\x1d\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xee\x02\x20!\nD\n\x04\
    \x04\x08\x02\x05\x12\x04\xf1\x02\x02/\x1a6\x20A\x20collection\x20of\x20k\
    nobs\x20to\x20tune\x20Virtual\x20AB\x20Compression\n\n\r\n\x05\x04\x08\
    \x02\x05\x04\x12\x04\xf1\x02\x02\n\n\r\n\x05\x04\x08\x02\x05\x06\x12\x04\
    \xf1\x02\x0b\x19\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\xf1\x02\x1a*\n\r\
    \n\x05\x04\x08\x02\x05\x03\x12\x04\xf1\x02-.\n\x82\x01\n\x02\x04\t\x12\
    \x06\xf6\x02\0\xfb\x02\x01\x1at\x20Definition\x20has\x20been\x20duplicat\
    ed\x20from\n\x20$ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata\
    .proto.\x20Keep\x20in\x20sync.\n\n\x0b\n\x03\x04\t\x01\x12\x04\xf6\x02\
    \x08\x10\n\x0c\n\x04\x04\t\x02\0\x12\x04\xf7\x02\x02#\n\r\n\x05\x04\t\
    \x02\0\x04\x12\x04\xf7\x02\x02\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xf7\
    \x02\x0b\x11\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xf7\x02\x12\x1e\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\xf7\x02!\"\n\x0c\n\x04\x04\t\x02\x01\x12\x04\
    \xf8\x02\x02\x1d\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xf8\x02\x02\n\n\r\n\
    \x05\x04\t\x02\x01\x05\x12\x04\xf8\x02\x0b\x10\n\r\n\x05\x04\t\x02\x01\
    \x01\x12\x04\xf8\x02\x11\x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xf8\x02\
    \x1b\x1c\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xf9\x02\x02\"\n\r\n\x05\x04\t\
    \x02\x02\x04\x12\x04\xf9\x02\x02\n\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\
    \xf9\x02\x0b\x0f\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xf9\x02\x10\x1d\n\r\
    \n\x05\x04\t\x02\x02\x03\x12\x04\xf9\x02\x20!\n\x0c\n\x04\x04\t\x02\x03\
    \x12\x04\xfa\x02\x02'\n\r\n\x05\x04\t\x02\x03\x04\x12\x04\xfa\x02\x02\n\
    \n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xfa\x02\x0b\x10\n\r\n\x05\x04\t\x02\
    \x03\x01\x12\x04\xfa\x02\x11\"\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xfa\
    \x02%&\n\x82\x01\n\x02\x04\n\x12\x06\xff\x02\0\x81\x03\x01\x1at\x20Defin\
    ition\x20has\x20been\x20duplicated\x20from\n\x20$ANDROID_BUILD_TOP/build\
    /tools/releasetools/ota_metadata.proto.\x20Keep\x20in\x20sync.\n\n\x0b\n\
    \x03\x04\n\x01\x12\x04\xff\x02\x08\x14\n\x0c\n\x04\x04\n\x02\0\x12\x04\
    \x80\x03\x02\"\n\r\n\x05\x04\n\x02\0\x04\x12\x04\x80\x03\x02\n\n\r\n\x05\
    \x04\n\x02\0\x06\x12\x04\x80\x03\x0b\x13\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\x80\x03\x14\x1d\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x80\x03\x20!\n\
    \x0c\n\x02\x04\x0b\x12\x06\x83\x03\0\xb4\x03\x01\n\x0b\n\x03\x04\x0b\x01\
    \x12\x04\x83\x03\x08\x1c\n\xa7\x01\n\x03\x04\x0b\t\x12\x04\x87\x03\x02\
    \x10\x1a\x99\x01\x20Only\x20present\x20in\x20major\x20version\x20=\x201.\
    \x20List\x20of\x20install\x20operations\x20for\x20the\n\x20kernel\x20and\
    \x20rootfs\x20partitions.\x20For\x20major\x20version\x20=\x202\x20see\
    \x20the\x20|partitions|\n\x20field.\n\n\x0c\n\x04\x04\x0b\t\0\x12\x04\
    \x87\x03\x0b\x0c\n\r\n\x05\x04\x0b\t\0\x01\x12\x04\x87\x03\x0b\x0c\n\r\n\
    \x05\x04\x0b\t\0\x02\x12\x04\x87\x03\x0b\x0c\n\x0c\n\x04\x04\x0b\t\x01\
    \x12\x04\x87\x03\x0e\x0f\n\r\n\x05\x04\x0b\t\x01\x01\x12\x04\x87\x03\x0e\
    \x0f\n\r\n\x05\x04\x0b\t\x01\x02\x12\x04\x87\x03\x0e\x0f\n1\n\x04\x04\
    \x0b\x02\0\x12\x04\x8a\x03\x022\x1a#\x20(At\x20time\x20of\x20writing)\
    \x20usually\x204096\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x8a\x03\x02\n\
    \n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x8a\x03\x0b\x11\n\r\n\x05\x04\x0b\
    \x02\0\x01\x12\x04\x8a\x03\x12\x1c\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\
    \x8a\x03\x1f\x20\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\x8a\x03!1\n\r\n\x05\
    \x04\x0b\x02\0\x07\x12\x04\x8a\x03,0\n\xa7\x02\n\x04\x04\x0b\x02\x01\x12\
    \x04\x91\x03\x02(\x1a\x98\x02\x20If\x20signatures\x20are\x20present,\x20\
    the\x20offset\x20into\x20the\x20blobs,\x20generally\n\x20tacked\x20onto\
    \x20the\x20end\x20of\x20the\x20file,\x20and\x20the\x20length.\x20We\x20u\
    se\x20an\x20offset\n\x20rather\x20than\x20a\x20bool\x20to\x20allow\x20fo\
    r\x20more\x20flexibility\x20in\x20future\x20file\x20formats.\n\x20If\x20\
    either\x20is\x20absent,\x20it\x20means\x20signatures\x20aren't\x20suppor\
    ted\x20in\x20this\n\x20file.\n\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\x91\
    \x03\x02\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x91\x03\x0b\x11\n\r\n\
    \x05\x04\x0b\x02\x01\x01\x12\x04\x91\x03\x12#\n\r\n\x05\x04\x0b\x02\x01\
    \x03\x12\x04\x91\x03&'\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\x92\x03\x02&\
    \n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\x92\x03\x02\n\n\r\n\x05\x04\x0b\
    \x02\x02\x05\x12\x04\x92\x03\x0b\x11\n\r\n\x05\x04\x0b\x02\x02\x01\x12\
    \x04\x92\x03\x12!\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x92\x03$%\n4\n\
    \x03\x04\x0b\t\x12\x04\x95\x03\x02\x19\x1a'\x20Fields\x20deprecated\x20i\
    n\x20major\x20version\x202.\n\n\x0c\n\x04\x04\x0b\t\x02\x12\x04\x95\x03\
    \x0b\x0c\n\r\n\x05\x04\x0b\t\x02\x01\x12\x04\x95\x03\x0b\x0c\n\r\n\x05\
    \x04\x0b\t\x02\x02\x12\x04\x95\x03\x0b\x0c\n\x0c\n\x04\x04\x0b\t\x03\x12\
    \x04\x95\x03\r\x0e\n\r\n\x05\x04\x0b\t\x03\x01\x12\x04\x95\x03\r\x0e\n\r\
    \n\x05\x04\x0b\t\x03\x02\x12\x04\x95\x03\r\x0e\n\x0c\n\x04\x04\x0b\t\x04\
    \x12\x04\x95\x03\x0f\x10\n\r\n\x05\x04\x0b\t\x04\x01\x12\x04\x95\x03\x0f\
    \x10\n\r\n\x05\x04\x0b\t\x04\x02\x12\x04\x95\x03\x0f\x10\n\x0c\n\x04\x04\
    \x0b\t\x05\x12\x04\x95\x03\x11\x12\n\r\n\x05\x04\x0b\t\x05\x01\x12\x04\
    \x95\x03\x11\x12\n\r\n\x05\x04\x0b\t\x05\x02\x12\x04\x95\x03\x11\x12\n\
    \x0c\n\x04\x04\x0b\t\x06\x12\x04\x95\x03\x13\x15\n\r\n\x05\x04\x0b\t\x06\
    \x01\x12\x04\x95\x03\x13\x15\n\r\n\x05\x04\x0b\t\x06\x02\x12\x04\x95\x03\
    \x13\x15\n\x0c\n\x04\x04\x0b\t\x07\x12\x04\x95\x03\x16\x18\n\r\n\x05\x04\
    \x0b\t\x07\x01\x12\x04\x95\x03\x16\x18\n\r\n\x05\x04\x0b\t\x07\x02\x12\
    \x04\x95\x03\x16\x18\n\x99\x01\n\x04\x04\x0b\x02\x03\x12\x04\x99\x03\x02\
    3\x1a\x8a\x01\x20The\x20minor\x20version,\x20also\x20referred\x20as\x20\
    \"delta\x20version\",\x20of\x20the\x20payload.\n\x20Minor\x20version\x20\
    0\x20is\x20full\x20payload,\x20everything\x20else\x20is\x20delta\x20payl\
    oad.\n\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\x99\x03\x02\n\n\r\n\x05\x04\
    \x0b\x02\x03\x05\x12\x04\x99\x03\x0b\x11\n\r\n\x05\x04\x0b\x02\x03\x01\
    \x12\x04\x99\x03\x12\x1f\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x99\x03\"\
    $\n\r\n\x05\x04\x0b\x02\x03\x08\x12\x04\x99\x03%2\n\r\n\x05\x04\x0b\x02\
    \x03\x07\x12\x04\x99\x0301\n\x81\x03\n\x04\x04\x0b\x02\x04\x12\x04\xa1\
    \x03\x02+\x1a\xf2\x02\x20Only\x20present\x20in\x20major\x20version\x20>=\
    \x202.\x20List\x20of\x20partitions\x20that\x20will\x20be\n\x20updated,\
    \x20in\x20the\x20order\x20they\x20will\x20be\x20updated.\x20This\x20fiel\
    d\x20replaces\x20the\n\x20|install_operations|,\x20|kernel_install_opera\
    tions|\x20and\x20the\n\x20|{old,new}_{kernel,rootfs}_info|\x20fields\x20\
    used\x20in\x20major\x20version\x20=\x201.\x20This\n\x20array\x20can\x20h\
    ave\x20more\x20than\x20two\x20partitions\x20if\x20needed,\x20and\x20they\
    \x20are\x20identified\n\x20by\x20the\x20partition\x20name.\n\n\r\n\x05\
    \x04\x0b\x02\x04\x04\x12\x04\xa1\x03\x02\n\n\r\n\x05\x04\x0b\x02\x04\x06\
    \x12\x04\xa1\x03\x0b\x1a\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xa1\x03\
    \x1b%\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\xa1\x03(*\nz\n\x04\x04\x0b\
    \x02\x05\x12\x04\xa5\x03\x02$\x1al\x20The\x20maximum\x20timestamp\x20of\
    \x20the\x20OS\x20allowed\x20to\x20apply\x20this\x20payload.\n\x20Can\x20\
    be\x20used\x20to\x20prevent\x20downgrading\x20the\x20OS.\n\n\r\n\x05\x04\
    \x0b\x02\x05\x04\x12\x04\xa5\x03\x02\n\n\r\n\x05\x04\x0b\x02\x05\x05\x12\
    \x04\xa5\x03\x0b\x10\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\xa5\x03\x11\
    \x1e\n\r\n\x05\x04\x0b\x02\x05\x03\x12\x04\xa5\x03!#\n;\n\x04\x04\x0b\
    \x02\x06\x12\x04\xa8\x03\x02D\x1a-\x20Metadata\x20related\x20to\x20all\
    \x20dynamic\x20partitions.\n\n\r\n\x05\x04\x0b\x02\x06\x04\x12\x04\xa8\
    \x03\x02\n\n\r\n\x05\x04\x0b\x02\x06\x06\x12\x04\xa8\x03\x0b#\n\r\n\x05\
    \x04\x0b\x02\x06\x01\x12\x04\xa8\x03$>\n\r\n\x05\x04\x0b\x02\x06\x03\x12\
    \x04\xa8\x03AC\nQ\n\x04\x04\x0b\x02\x07\x12\x04\xab\x03\x02$\x1aC\x20If\
    \x20the\x20payload\x20only\x20updates\x20a\x20subset\x20of\x20partitions\
    \x20on\x20the\x20device.\n\n\r\n\x05\x04\x0b\x02\x07\x04\x12\x04\xab\x03\
    \x02\n\n\r\n\x05\x04\x0b\x02\x07\x05\x12\x04\xab\x03\x0b\x0f\n\r\n\x05\
    \x04\x0b\x02\x07\x01\x12\x04\xab\x03\x10\x1e\n\r\n\x05\x04\x0b\x02\x07\
    \x03\x12\x04\xab\x03!#\np\n\x04\x04\x0b\x02\x08\x12\x04\xaf\x03\x02#\x1a\
    b\x20Information\x20on\x20compressed\x20APEX\x20to\x20figure\x20out\x20h\
    ow\x20much\x20space\x20is\x20required\x20for\n\x20their\x20decompression\
    \n\n\r\n\x05\x04\x0b\x02\x08\x04\x12\x04\xaf\x03\x02\n\n\r\n\x05\x04\x0b\
    \x02\x08\x06\x12\x04\xaf\x03\x0b\x13\n\r\n\x05\x04\x0b\x02\x08\x01\x12\
    \x04\xaf\x03\x14\x1d\n\r\n\x05\x04\x0b\x02\x08\x03\x12\x04\xaf\x03\x20\"\
    \nX\n\x04\x04\x0b\x02\t\x12\x04\xb3\x03\x02,\x1aJ\x20Security\x20patch\
    \x20level\x20of\x20the\x20device,\x20usually\x20in\x20the\x20format\x20o\
    f\n\x20yyyy-mm-dd\n\n\r\n\x05\x04\x0b\x02\t\x04\x12\x04\xb3\x03\x02\n\n\
    \r\n\x05\x04\x0b\x02\t\x05\x12\x04\xb3\x03\x0b\x11\n\r\n\x05\x04\x0b\x02\
    \t\x01\x12\x04\xb3\x03\x12&\n\r\n\x05\x04\x0b\x02\t\x03\x12\x04\xb3\x03)\
    +\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(13);
            messages.push(Extent::generated_message_descriptor_data());
            messages.push(Signatures::generated_message_descriptor_data());
            messages.push(PartitionInfo::generated_message_descriptor_data());
            messages.push(InstallOperation::generated_message_descriptor_data());
            messages.push(CowMergeOperation::generated_message_descriptor_data());
            messages.push(PartitionUpdate::generated_message_descriptor_data());
            messages.push(DynamicPartitionGroup::generated_message_descriptor_data());
            messages.push(VABCFeatureSet::generated_message_descriptor_data());
            messages.push(DynamicPartitionMetadata::generated_message_descriptor_data());
            messages.push(ApexInfo::generated_message_descriptor_data());
            messages.push(ApexMetadata::generated_message_descriptor_data());
            messages.push(DeltaArchiveManifest::generated_message_descriptor_data());
            messages.push(signatures::Signature::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(install_operation::Type::generated_enum_descriptor_data());
            enums.push(cow_merge_operation::Type::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
